<html><head></head><body><header  ><h1 id="NIL"  >cl-synthesizer</h1><p>A Modular Audio Synthesizer Engine implemented in Common Lisp.
    <p>cl-synthesizer is an easy to use library which follows the approach of
      a classical hardware modular synthesizer, where modules are put into a rack and patched together
      with cables.</p>
</p>cl-synthesizer has been developed with the following principles in mind:
<ul>
    <li>No dependencies to binding libraries. The Common Lisp Standard Library shall it be.</li>
    <li>Extensive unit testing.</li>
    <li>Extensive profiling of consing and execution speed.</li>
</ul><p>The source code of cl-synthesizer can be found <a href="https://github.com/Frechmatz/cl-synthesizer">here</a>.</p></header><nav  ><h1 id="NIL"  >Table of contents</h1><ul  ><li  > <a href="#Installation-1">Installation</a></li><li  ><a href="#Examples-2">Examples</a><ul><li  > <a href="#440Hz sine-3">440Hz sine</a></li><li  > <a href="#Two frequency modulated saws-4">Two frequency modulated saws</a></li></ul></li><li  ><a href="#Concepts-5">Concepts</a><ul><li  > <a href="#Environment-6">Environment</a></li><li  > <a href="#Module-7">Module</a></li><li  > <a href="#Rack-8">Rack</a></li><li  > <a href="#Monitor-9">Monitor</a></li></ul></li><li  ><a href="#API-10">API</a><ul><li  ><a href="#Environment-11">Environment</a><ul><li  > <a href="#make-environment-12">make-environment</a></li></ul></li><li  ><a href="#Rack-13">Rack</a><ul><li  > <a href="#make-rack-14">make-rack</a></li><li  > <a href="#add-module-15">add-module</a></li><li  > <a href="#add-patch-16">add-patch</a></li><li  > <a href="#get-module-17">get-module</a></li><li  > <a href="#get-module-name-18">get-module-name</a></li><li  > <a href="#find-module-19">find-module</a></li><li  > <a href="#get-patches-20">get-patches</a></li><li  > <a href="#get-modules-21">get-modules</a></li><li  > <a href="#add-hook-22">add-hook</a></li><li  > <a href="#play-rack-23">play-rack</a></li><li  > <a href="#is-rack-24">is-rack</a></li><li  > <a href="#get-environment-25">get-environment</a></li></ul></li><li  ><a href="#Modules-26">Modules</a><ul><li  > <a href="#VCO-27">VCO</a></li><li  > <a href="#VCA-28">VCA</a></li><li  > <a href="#ADSR-29">ADSR</a></li><li  > <a href="#Multiple-30">Multiple</a></li><li  > <a href="#MIDI Polyphonic Interface-31">MIDI Polyphonic Interface</a></li><li  > <a href="#MIDI Monophonic Interface-32">MIDI Monophonic Interface</a></li><li  > <a href="#MIDI CC Interface-33">MIDI CC Interface</a></li><li  > <a href="#MIDI Sequencer-34">MIDI Sequencer</a></li><li  > <a href="#Fixed Output-35">Fixed Output</a></li><li  > <a href="#Adder-36">Adder</a></li><li  > <a href="#Mixer-37">Mixer</a></li><li  > <a href="#Trigger-38">Trigger</a></li><li  > <a href="#Ramp-39">Ramp</a></li><li  > <a href="#Sustain-40">Sustain</a></li><li  > <a href="#Wave File Writer-41">Wave File Writer</a></li><li  > <a href="#CSV File Writer-42">CSV File Writer</a></li></ul></li><li  ><a href="#Monitor-43">Monitor</a><ul><li  > <a href="#add-monitor-44">add-monitor</a></li><li  > <a href="#wave-handler-45">wave-handler</a></li><li  > <a href="#csv-handler-46">csv-handler</a></li></ul></li><li  ><a href="#MIDI-47">MIDI</a><ul><li  > <a href="#MIDI Event-48">MIDI Event</a></li><li  > <a href="#MIDI Utilities-49">MIDI Utilities</a></li></ul></li><li  > <a href="#Conditions-50">Conditions</a></li></ul></li><li  > <a href="#Acknowledgements-51">Acknowledgements</a></li></ul></nav><section  ><h1 id="Installation-1"  >Installation</h1><pre><code>cd ~/quicklisp/local-projects
git clone https://github.com/Frechmatz/cl-wave-file-writer.git
git clone https://github.com/Frechmatz/cl-synthesizer.git
(ql:quickload "cl-synthesizer")</code></pre><h1 id="Examples-2"  >Examples</h1><h2 id="440Hz sine-3"  >440Hz sine</h2><p><pre><code>(defpackage :cl-synthesizer-patches-sine
  (:documentation "440Hz sine")
  (:use :cl))

(in-package :cl-synthesizer-patches-sine)

(defun example ()
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment)
               :output-sockets '(:sine))))
    
    (cl-synthesizer:add-module
     rack
     "VCO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 440.0 :v-peak 5.0)

    (cl-synthesizer:add-patch rack "VCO" :sine "OUTPUT" :sine)
    
    ;; We do not want to have a hard wired Wave-Writer module in our rack.
    ;; Let the file writing stuff be handled by a monitor.
    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-wave-handler:make-backend
     '(("VCO" :output-socket :sine))
     :filename "src/lisp/cl-synthesizer/docs/sine.wav")

    rack))

(defparameter *duration-seconds* 3.0)
;; parameter and corresponding OUTPUT patches only required for experimental audio output
(defparameter *audio-output-sockets* '(:sine))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds *duration-seconds*)))

;; (run-example)</code></pre></p><p><audio controls preload="none">Your browser does not support the <code>audio</code> element.<source src="sine.wav?cb=3811271337" type="audio/wav"></audio></p><h2 id="Two frequency modulated saws-4"  >Two frequency modulated saws</h2><p><pre><code>(defpackage :cl-synthesizer-patches-siren
  (:use :cl)
  (:documentation "Two frequency modulated saws"))

(in-package :cl-synthesizer-patches-siren)

(defun make-voice (name environment &amp;key lfo-frequency vco-frequency)
  "Frequency modulated saw"
  (declare (ignore name))
  (let ((voice
         (cl-synthesizer:make-rack
          :environment environment
          :output-sockets '(:audio))))
    
    (cl-synthesizer:add-module
     voice "LFO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency lfo-frequency :v-peak 5.0)

    (cl-synthesizer:add-module
     voice "VCO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency vco-frequency :v-peak 5.0 :cv-lin-hz-v 20.0)

    (cl-synthesizer:add-patch voice "LFO" :sine "VCO" :cv-lin)
    (cl-synthesizer:add-patch voice "VCO" :saw "OUTPUT" :audio)
    
    voice))
  
(defun example ()
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment)
               :output-sockets '(:left :right))))

    (cl-synthesizer:add-module
     rack "VOICE-1" #'make-voice :lfo-frequency 1.0 :vco-frequency 440.0)
    (cl-synthesizer:add-module
     rack "VOICE-2" #'make-voice :lfo-frequency 2.0 :vco-frequency 442.0)

    (cl-synthesizer:add-patch rack "VOICE-1" :audio "OUTPUT" :left)
    (cl-synthesizer:add-patch rack "VOICE-2" :audio "OUTPUT" :right)

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-wave-handler:make-backend
     '(("VOICE-1" :output-socket :audio)
       ("VOICE-2" :output-socket :audio))
     :filename "src/lisp/cl-synthesizer/docs/siren.wav")
    
    rack))

(defparameter *duration-seconds* 2.0)
;; parameter and corresponding OUTPUT patches only required for experimental audio output
(defparameter *audio-output-sockets* '(:left :right))

(defun run-example ()
  (cl-synthesizer:play-rack
   (example)
   :duration-seconds *duration-seconds*))
  
;;(run-example)</code></pre></p><p><audio controls preload="none">Your browser does not support the <code>audio</code> element.<source src="siren.wav?cb=3811271337" type="audio/wav"></audio></p><h1 id="Concepts-5"  >Concepts</h1><h2 id="Environment-6"  >Environment</h2><p>An environment defines properties such as the sample rate and the home directory of the synthesizer. An environment is represented by a property list.</p><p><pre><code>(let ((environment (cl-synthesizer:make-environment)))
  ...)</code></pre></p><h2 id="Module-7"  >Module</h2><p>Modules are the heart of cl-synthesizer because they are responsible for producing the actual audio data.</p>
<p>Modules do have a name, inputs, outputs and a shutdown function. The inputs/outputs are represented by keywords and are so called sockets. The shutdown function can be used to release resources 
that have been allocated by the module, for example opened files.</p>
<p>Beside the input/output sockets a module can also provide "state sockets".
State sockets expose internal states of the module. These sockets are not accessible when connecting modules with each other. They are meant 
to be a debugging/analysis tool. For example to create a plot of the phase of an oscillator over time, a :phase state socket in conjunction with a Monitor is the way to go.</p>
<p>A module is represented by a property list. This list provides functions such as to get the input sockets, to get the output sockets, to get the state sockets, 
to set input values, to retrieve output values, to update the module, to shutdown the module and so on.</p>
<p>A module must provide a factory/instantiation function. The typical name of this function is "make-module". When a module is added to the synthesizer then not the 
    readily instantiated module is passed, but its factory function. This function is called by the synthesizer. The synthesizer passes the module name, 
    the environment and any arbitrary initialization parameters to it.</p>
<p>A module can implement all its logic on its own but it can also use other modules. An example of a module using other modules is the
    <a href="https://github.com/Frechmatz/cl-synthesizer/blob/master/src/modules/mixer.lisp">Mixer</a>.</p>
<p>For each input/output socket that a module exposes, it must provide a corresponding setter/getter function. When processing an update, the synthesizer sets the inputs of the module via successive calls to the input setters. An input setter must not change the current output state of the module. When all inputs have been set, the synthesizer calls the update function of the module, which has no arguments. The update function must update the states of the output sockets by using the previously set input values.</p>
<p>Lets create a module:</p><p><pre><code>(defpackage :blueprint-module
  (:use :cl)
  (:export
   :make-module))

(in-package :blueprint-module)

(defun make-module (name environment &amp;key module-param)
  (let ((input-1 nil) (input-2 nil) (output-1 nil) (output-2 nil))
    (let ((inputs
           (list
            :input-1 (lambda(value) (setf input-1 value))
            :input-2 (lambda(value) (setf input-2 value))))
          (outputs
           (list
            :output-1 (lambda() output-1)
            :output-2 (lambda() output-2))))
      (list
       :inputs (lambda () inputs)
       :outputs (lambda () outputs)
       :update (lambda ()
                 (setf output-1 input-1)
                 (setf output-2 input-2))
       :state (lambda (key)
                    (if (eq key :module-param) module-param nil))
       :shutdown (lambda ())))))</code></pre></p><p>Now lets add our module to a rack (Racks are explained in the following chapter):</p><p><pre><code>(let ((rack ...))
  (cl-synthesizer:add-module rack "MODULE-1" #'blueprint-module:make-module :module-param 1234))</code></pre></p><h2 id="Rack-8"  >Rack</h2><p>Racks contain modules and their connections which each other. The connections are so called "Patches". A rack is represented by a property list, which is fully compatible with a module. Beside the module functionality a rack provides Module and Patch management, Hooks and Compilation. Racks are instantiated via "cl-synthesizer:make-rack"</p><p><pre><code>(let ((rack (cl-synthesizer:make-rack :environment (cl-synthesizer:make-environment)))) ... )</code></pre></p><p>After the rack has been created, modules and patches can be added to it.</p><p><pre><code>(let ((rack (cl-synthesizer:make-rack :environment (cl-synthesizer:make-environment))))
  (cl-synthesizer:add-module rack "LFO" ...)
  (cl-synthesizer:add-module rack "VCO" ...)
  (cl-synthesizer:add-patch rack "LFO" :sine "VCO" :cv-lin))</code></pre></p><p>The rack is now ready to use and a "tick" can be processed. When a tick is to be processed, the rack checks if it has been modified, and if yes, a compilation occurs. The compilation step processes the modules and patch table of the rack in order to eliminate/minimize any expensive property list lookups during the actual execution.</p><p><pre><code>(funcall (getf rack :update))</code></pre></p><p>Lets get the :sine output of the "VCO" module. The following snippet illustrates the low-level Api of the synthesizer. The recommended way to retrieve output values is to use a "Monitor‚Äù. Monitors are explained in the next chapter.</p><p><pre><code>(let ((module (cl-synthesizer:get-module rack "VCO")))
  (let ((module-outputs (funcall (getf module :outputs))))
    (let ((sine (funcall (getf module-outputs :sine))))
      (format t "Sine: ~a" sine))))</code></pre></p><p>When all things are done the rack should be shut down in order to release any resources that may have been allocated, such as opened files.</p><p><pre><code>(funcall (getf rack :shutdown))</code></pre></p><p>Racks may expose input and output sockets. When a rack exposes sockets it can be used like any other module when populating another rack. The inputs and outputs are accessible by the internal patching of the rack via so called "Bridge modules". "INPUT" provides the inputs, and "OUTPUT" the outputs of the rack.</p><p><pre><code>(let ((rack
       (cl-synthesizer:make-rack
        :environment ...
        :input-sockets '(:rack-input-1)
        :output-sockets '(:rack-output-1))))

  (cl-synthesizer:add-module rack "SOME-MODULE" ...)
  (cl-synthesizer:add-patch rack "INPUT" :rack-input-1 "SOME-MODULE" :module-input)
  (cl-synthesizer:add-patch rack "SOME-MODULE" :module-output "OUTPUT" :rack-output-1))</code></pre></p><p>A more comprehensive example can be found <a href="https://github.com/Frechmatz/cl-synthesizer/blob/master/patches/siren.lisp">here</a>.</p><h2 id="Monitor-9"  >Monitor</h2><p>Monitors are high-level Rack-Hooks. The purpose of a monitor
is to collect module states and pass them to a "Monitor-Backend". A backend may
for example generate a Wave file.</p> 
<p>Monitors provide a simple syntax for declaring the module sockets to be tracked (input, output and state) as well as any other settings supported by specific backends.</p>
<p>A backend is typically realized as a plain module, which declares
input sockets, output sockets, a shutdown function and so on. Backends are 
instantiated by a so called "Monitor-Handler".</p>
<p>A Monitor-Handler is a factory function whose purpose is to prepare the initialization 
parameters of a specific backend (e.g. a Wave-File-Writer module), to set up the 
mapping of the values collected by the monitor to input sockets of the backend 
and finally to instantiate it.</p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-monitor-example-1
  (:use :cl))

(in-package :cl-synthesizer-monitor-example-1)

(defun example ()
  "Monitor example"
  (let ((rack (cl-synthesizer:make-rack :environment (cl-synthesizer:make-environment))))
    
    (cl-synthesizer:add-module
     rack
     "VCO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 5.0 :v-peak 5.0)

    ;; Write the sine signal into a wave file
    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-wave-handler:make-backend
     '(("VCO" :output-socket :sine))
     :filename "cl-synthesizer-examples/monitor-example-1.wav")

    ;; Write all waveforms and the phase into a CSV file
    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-csv-handler:make-backend
     '(("VCO" :output-socket :sine :name "Sine")
       ("VCO" :output-socket :triangle :name "Triangle")
       ("VCO" :output-socket :saw :name "Saw")
       ("VCO" :output-socket :square :name "Square")
       ("VCO" :state :phase :name "Phase"))
     :filename "cl-synthesizer-examples/monitor-example-1.csv"
     :add-header t
     :column-separator ",")
    
    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 2)))

;; (run-example)</code></pre></p><h1 id="API-10"  >API</h1><h2 id="Environment-11"  >Environment</h2><h3 id="make-environment-12"  >make-environment</h3><b>make-environment</b>&nbsp;(&key (sample-rate 44100) (home-directory nil))<p>Creates an environment. An enviroment is a property list with the following keys:
    <ul>
	<li>:sample-rate Sample rate of the synthesizer.</li>
	<li>:home-directory The base output directory for wave files etc. Default value is the home directory
        of the current user.</li>
    </ul></p><h2 id="Rack-13"  >Rack</h2><h3 id="make-rack-14"  >make-rack</h3><b>make-rack</b>&nbsp;(&key environment (input-sockets nil) (output-sockets nil))<p>Creates a rack.<p>The function has the following arguments:
    <ul>
	<li>:environment The synthesizer environment.</li>
        <li>:input-sockets The input sockets to be exposed by the rack. The inputs
        can be patched with other modules via the bridge module "INPUT".</li>
        <li>:output-sockets The output sockets to be exposed by the rack. The outputs
        can be patched with other modules via the bridge module "OUTPUT".</li>
    </ul></p>
    <p>    
    The update function of the rack calls the update function of all embedded modules. If the 
    rack has already been shut down the function immediately returns <b>nil</b>.
    Othwerwise it returns <b>t</b>.
    </p><p>
    The shutdown function of the rack calls the shutdown handlers of all embedded modules and hooks. If the rack has 
    already been shut down the function immediately returns.
    </p></p><h3 id="add-module-15"  >add-module</h3><b>add-module</b>&nbsp;(rack module-name module-fn &rest args)<p>Adds a module to a rack. <p>The function has the following arguments:
    <ul>
	<li>rack The rack.</li>
	<li>module-name Unique name of the module, for example "VCO-1". If the name
	    is already used by another module an assembly-error is signalled.</li>
	<li>module-fn A function that instantiates the module. This function is
	    called by the rack with the following arguments:
	    <ul>
		<li>name Name of the module.</li>
		<li>environment The synthesizer environment.</li>
		<li>module-args Any additional arguments passed to add-module.</li>
	    </ul>
	    The module instantiation function must return a property list with the following keys:
	    <ul>
		<li>:inputs A function with no arguments that returns a property list representing the
                    input sockets and their corresponding setter functions that are exposed by the module.</br>
                    Example: <code>:inputs (lambda() (list :input-1 (lambda(value) (setf input-1 value))))</code>
                    </br>Modules are supposed to buffer this list as the inputs might be requested several times.
                </li>
		<li>:outputs A function with no arguments that returns a property list representing 
                    the  output sockets and their corresponding getter functions that exposed by the module.</br>
                    Example: <code>:outputs (lambda() (list :output-1 (lambda() output-1)))</code>
                    </br>Modules are supposed to buffer this list as the outputs might be requested several times.
                </li>
		<li>:update A function with no arguments that updates the outputs according to the previously set inputs.</li>
		<li>:shutdown An optional function with no arguments that is called when the rack
		    is shutting down.</li>
                <li>:state An optional function that can be used to expose internal states 
                    of the module, for example a VCO may expose its frequency. The function has one 
                    argument that consists of a keyword identifying the requested state, for 
                    example :frequency.</li>
	    </ul>
	</li>
	<li>&rest args Arbitrary additional arguments to be passed to the module instantiation function.
	    These arguments typically consist of keyword parameters.</li>
    </ul></p>
    Returns the module.</p><h3 id="add-patch-16"  >add-patch</h3><b>add-patch</b>&nbsp;(rack output-module-name output-socket input-module-name input-socket)<p>Adds a patch to the rack. A patch is an unidirectional connection between an output socket
    of a source module and an input socket of a destination module. The rack supports cycles 
    which means that an output socket of a module can be patched with one of its inputs (typically via
    multiple hops through other modules). <p>The function has the following arguments:
    <ul>
	<li>rack The rack.</li>
	<li>output-module-name Name of the output (source) module.</li>
	<li>output-socket A keyword representing one of the output sockets of the
	    output module.</li>
	<li>input-module-name Name of the input (destination) module.</li>
	<li>input-socket A keyword representing one of the input sockets of the
	    input module.</li>
    </ul></p>
    <p>The rack signals an assembly-error in the following cases:
    <ul>
	<li>A module with the given output name does not exist.</li>
	<li>A module with the given input name does not exist.</li>
	<li>The given output-socket is already connected with a module.</li>
	<li>The given output-socket is not exposed by the output module.</li>
	<li>The given input-socket is already connected with a module.</li>
	<li>The given input-socket is not exposed by the input module.</li>
    </ul></p></p><h3 id="get-module-17"  >get-module</h3><b>get-module</b>&nbsp;(rack name)<p>Get a module of a rack. <p>The function has the following arguments:
    <ul>
      <li>rack The rack.</li>
      <li>name The name of the module.</li>
    </ul></p>
   Returns the module or nil.</p><h3 id="get-module-name-18"  >get-module-name</h3><b>get-module-name</b>&nbsp;(rack module)<p>Get the name of a module. <p>The function has the following arguments:
    <ul>
	<li>rack The rack.</li>
	<li>module The module.</li>
    </ul></p>
   Returns the name or nil if the module does not belong to the rack</p><h3 id="find-module-19"  >find-module</h3><b>find-module</b>&nbsp;(rack module-path)<p>Get a module of a rack. <p>The function has the following arguments:
    <ul>
      <li>rack The root rack.</li>
      <li>module-path The path of the module within the rack (through multiple nested racks).</br>
         Example 1: "VCO"</br> 
         Example 2: '("VOICE-1" "VCO")</li>
    </ul></p>
   Returns nil or a values object consisting of the rack of the module, the module name and the module itself.</p><h3 id="get-patches-20"  >get-patches</h3><b>get-patches</b>&nbsp;(rack)<p>Get all patches of a rack. <p>The function has the following arguments:
    <ul>
	<li>rack The rack.</li>
    </ul></p>
   Returns a list of property lists with the following keys:
   <ul>
     <li>:output-name Name of the output module.</li>
     <li>:output-socket Output socket. </li>
     <li>:input-name Name of the input module. </li>
     <li>:input-socket Input socket.</li>
   </ul></p><h3 id="get-modules-21"  >get-modules</h3><b>get-modules</b>&nbsp;(rack)<p>Get all modules of a rack. <p>The function has the following arguments:
    <ul>
	<li>rack The rack.</li>
    </ul></p>
    Returns a list of modules where each module consists of a property list with
    the following keys:
    <ul>
       <li>:module The module</li>
       <li>:name Name of the module</li>
    </ul></p><h3 id="add-hook-22"  >add-hook</h3><b>add-hook</b>&nbsp;(rack hook)<p>Adds a hook to the rack. A hook is called each time after the rack has updated its state.
   <p>A hook consists a property list with the following keys:
   <ul>
      <li>:update A function with no arguments that is called after the rack has updated its state.</li>
      <li>:shutdown A function with no arguments that is called when the rack is shutting down.</li>
   </ul></p>
   Hooks must not modify the rack. See also <b>cl-synthesizer-monitor:add-monitor</b>.</p><h3 id="play-rack-23"  >play-rack</h3><b>play-rack</b>&nbsp;(rack &key duration-seconds)<p>A utility function that "plays" the rack by consecutively calling its update function
    for a given number of "ticks". <p>The function has the following arguments:
    <ul>
	<li>rack The rack.</li>
	<li>:duration-seconds Duration in seconds of how long to play the rack. If for
	    example the duration is 2 seconds and the sample rate of the rack as declared
	    by its environment is 44100, then the update function of the rack will be called 88200 times.</li>
    </ul></p></p><h3 id="is-rack-24"  >is-rack</h3><b>is-rack</b>&nbsp;(module)<p>Returns <b>t</b> if the given module represents a rack.</p><h3 id="get-environment-25"  >get-environment</h3><b>get-environment</b>&nbsp;(rack)<p>Returns the environment of the rack.</p><h2 id="Modules-26"  >Modules</h2><h3 id="VCO-27"  >VCO</h3><b>make-module</b>&nbsp;(name environment &key base-frequency v-peak (cv-lin-hz-v 0.0) (duty-cycle 0.5)
 (phase-offset 0.0) (f-max 12000.0) (wave-forms nil) (sync-threshold 2.5))<p>Creates a Voltage Controlled Oscillator module with 1V/Octave and linear frequency modulation
   inputs. The oscillator has through-zero support.
   <p>The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:base-frequency The frequency emitted by the oscillator when all frequency control 
           voltages are 0.</li>
	<li>:f-max Absolute value of the maximum frequency of the oscillator. f-max must be greater than 0.</li>
	<li>:cv-lin-hz-v Frequency/Volt setting for the linear frequency modulation input :cv-lin.</li>
	<li>:v-peak Absolute value of the output peak voltage emitted by the oscillator.</li>
	<li>:duty-cycle The duty cycle of the square wave. 0 <= duty-cycle <= 1.</li>
	<li>:phase-offset A phase offset in radians.</li>
        <li>:wave-forms A list of keywords that declares the wave forms that are to be exposed by 
          the module. Each keyword must be one of :sine, :saw, :triangle or :square. By default
          the module exposes all wave forms. Declaring the required wave forms is highly recommended
          as this can improve the execution speed of the module significantly (up to 50%).</li>
        <li>:sync-threshold Minimum value of the :sync input that indicates 
            that a phase reset is to be applied.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
	<li>:cv-exp Exponential frequency control voltage. For a given base-frequency of 440Hz a
	    control voltage of 1.0 results in a frequency of 880Hz and a control
	    voltage of -1.0 results in a frequency of 220Hz.
	</li>
        <li>:cv-lin Bipolar linear frequency control voltage. Example: If the :cv-lin-hz-v setting
           of the oscillator is 77Hz a :cv-lin input value of 2.0V results in a frequency of 154Hz and 
           a :cv-lin input value of -2.0V results in a frequency of -154Hz.</li>
        <li>:sync A trigger signal that resets the phase.</li>
    </ul>
    The frequency of the oscillator is calculated by adding the frequencies resulting from the
    :cv-lin and :cv-exp inputs. The frequency is clipped according to the :f-max setting.</p>
    <p>The module has the following outputs (depending on the :wave-forms argument):
    <ul>
	<li>:sine A sine wave.</li>
	<li>:triangle A triangle wave.</li>
	<li>:saw A saw wave.</li>
	<li>:square A square wave.</li>
    </ul></p>
    <p>The module exposes the following states via the state function:
       <ul>
          <li>:frequency The current frequency of the module.</li>
          <li>:linear-frequency The current linear frequency portion of the module.</li>
          <li>:exponential-frequency The current exponential frequency portion of the module.</li>
          <li>:phase The current phase in radians (0..2PI).</li>
       </ul>
    </p></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-vco-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-vco-example-1)

(defun example ()
  "Write all wave forms into a Wave and a Csv file"
  (let ((rack (cl-synthesizer:make-rack :environment (cl-synthesizer:make-environment))))
    (cl-synthesizer:add-module
     rack
     "VCO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 10.0 :v-peak 5.0)

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-wave-handler:make-backend
     '(("VCO" :output-socket :sine)
       ("VCO" :output-socket :triangle)
       ("VCO" :output-socket :saw)
       ("VCO" :output-socket :square))
     :filename "cl-synthesizer-examples/vco-example-1.wav")

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-csv-handler:make-backend
     '(("VCO" :output-socket :sine :name "Sine")
       ("VCO" :output-socket :triangle :name "Triangle")
       ("VCO" :output-socket :saw :name "Saw")
       ("VCO" :output-socket :square :name "Square"))
     :filename "cl-synthesizer-examples/vco-example-1.csv"
     :add-header t
     :column-separator ",")
    
    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 1)))

;; (run-example)</code></pre></p><h3 id="VCA-28"  >VCA</h3><b>make-module</b>&nbsp;(name environment &key cv-max (initial-gain 0.0) (exponential nil))<p>Creates a Voltage Controlled Amplifier/Attenuator module. The VCA multiplies an
    incoming signal with a factor of 0..1. <p>The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:cv-max The value of the effective amplification control voltage that represents the maximum
	    amplification of 1.0.</li>
	<li>:initial-gain An offset that is added to the amplification control voltage.</li>
        <li>:exponential If t then the amplification will have an exponential characteristic.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
	<li>:cv Amplification control voltage.</li>
	<li>:input Input signal to be amplified.</li>
	<li>:gain An offset that is added to the amplification control voltage.</li>
    </ul>
    The effective amplification voltage is v = :cv + :gain + :initial-gain, where 0.0 <= v <= :cv-max.</p>
    <p>The module has the following outputs:
    <ul>
	<li>:output Amplified input signal.</li>
    </ul></p></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-vca-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-vca-example-1)

(defun example ()
  "Amplification of a 10kHz sine wave with a bipolar triangular signal."
  (let ((rack (cl-synthesizer:make-rack :environment (cl-synthesizer:make-environment))))

    ;; Set up oscillator modulating the amplification
    (cl-synthesizer:add-module
     rack "LFO-CV"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 0.5
     :v-peak 5.0)

    ;; set up oscillator providing the audio signal
    (cl-synthesizer:add-module
     rack "VCO-AUDIO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 5.0
     :v-peak 5.0)

    ;; Set up VCA
    (cl-synthesizer:add-module
     rack "VCA"
     #'cl-synthesizer-modules-vca:make-module
     :cv-max 5.0
     :exponential t)

    ;; Add patches
    (cl-synthesizer:add-patch rack "VCO-AUDIO" :sine "VCA" :input)
    (cl-synthesizer:add-patch rack "LFO-CV" :triangle "VCA" :cv)

    ;; Write VCA inputs/outputs into a CSV file
    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-csv-handler:make-backend
     '(("VCA" :input-socket :cv :name "CV")
       ("VCA" :input-socket :input :name "Input")
       ("VCA" :output-socket :output :name "Output"))
     :filename "cl-synthesizer-examples/vca-example-1.csv")
    
    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 5.0)))

;; (run-example)</code></pre></p><h3 id="ADSR-29"  >ADSR</h3><b>make-module</b>&nbsp;(name environment &key attack-time-ms attack-target-output decay-time-ms
 decay-target-output release-time-ms (time-cv-to-time-ms nil)
 (gate-threshold 2.5) (backward-coupled nil) (exponential nil))<p>Creates an envelope generator module with the phases Attack, Decay, Sustain and Release.
    <p>The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:attack-time-ms Duration of the attack phase in milliseconds.</li>
	<li>:attack-target-output Target value of the attack phase.</li>
	<li>:decay-time-ms Duration of the decay phase in milliseconds.</li>
	<li>:decay-target-output Target value of the decay phase.</li>
	<li>:release-time-ms Duration of the release phase in milliseconds. The release phase climbs to 0.0.</li>
	<li>:time-cv-to-time-ms Optional function that converts a time control voltage to a duration in milliseconds. The default implementation is 1000ms/1V.</li>
	<li>:gate-threshold Minimum value of the :gate input that indicates that the gate is on.</li>
        <li>:backward-coupled If t then the output signal of the envelope will be connected with 
            the input of the attack phase. This can be used to avoid sudden jumps of the envelope 
            as the attack phase by default starts at 0.0.</li>
        <li>:exponential If t then the envelope will have exponential characteristic.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
	<li>:gate The gate signal (see also :gate-threshold). The envelope starts working when the
	gate input switches to "on" and enters into the release phase when it switches to "off".</li>
	<li>:attack-cv-time Modulates the climbing time of the attack phase (see also :time-cv-to-time-ms).</li>
	<li>:release-cv-time Modulates the climbing time of the release phase (see also :time-cv-to-time-ms).</li>
    </ul></p>
    <p>The module has the following outputs:
    <ul>
	<li>:cv The envelope.</li>
    </ul></p></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-adsr-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-adsr-example-1)

(defun make-voice (name environment &amp;key exponential)
  (declare (ignore name))
  (let ((rack (cl-synthesizer:make-rack
               :environment environment
               :input-sockets '(:gate)
               :output-sockets '(:adsr-out))))

    (cl-synthesizer:add-module
     rack "ADSR"
     #'cl-synthesizer-modules-adsr:make-module
     :attack-time-ms 500 :attack-target-output 5.0
     :decay-time-ms 250 :decay-target-output -3.0
     :release-time-ms 1000
     :exponential exponential)

    (cl-synthesizer:add-patch rack "INPUT" :gate "ADSR" :gate)
    (cl-synthesizer:add-patch rack "ADSR" :cv "OUTPUT" :adsr-out)

    rack))

(defun example ()
  "ADSR example. Linear vs. Exponential"
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment))))
    
    (cl-synthesizer:add-module
     rack "MIDI-SEQUENCER"
     #'cl-synthesizer-modules-midi-sequencer:make-module :events
     (list 
      (list :timestamp-milli-seconds 0
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-on-event 1 69 100)))
      (list :timestamp-milli-seconds 1500
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-off-event 1 69 100)))))

    (cl-synthesizer:add-module
     rack "MIDI-IFC"
     #'cl-synthesizer-modules-midi-polyphonic-interface:make-module :voice-count 1)

    (cl-synthesizer:add-patch rack "MIDI-SEQUENCER" :midi-events "MIDI-IFC" :midi-events)
    
    (cl-synthesizer:add-module
     rack "GATE-MULTIPLE"
     #'cl-synthesizer-modules-multiple:make-module
     :output-count 2)

    (cl-synthesizer:add-patch rack "MIDI-IFC" :gate-1 "GATE-MULTIPLE" :input)

    (cl-synthesizer:add-module
     rack "LINEAR" #'make-voice :exponential nil)
    (cl-synthesizer:add-patch rack "GATE-MULTIPLE" :output-1 "LINEAR" :gate)
    
    (cl-synthesizer:add-module
     rack "EXPONENTIAL" #'make-voice :exponential t)
    (cl-synthesizer:add-patch rack "GATE-MULTIPLE" :output-2 "EXPONENTIAL" :gate)

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-csv-handler:make-backend
     '(("GATE-MULTIPLE" :input-socket :input :name "Gate")
       ("LINEAR" :output-socket :adsr-out :name "ADSR Linear")
       ("EXPONENTIAL" :output-socket :adsr-out :name "ADSR Exponential"))
     :filename "cl-synthesizer-examples/adsr-example-1.csv")
    
    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 3)))

;; (run-example)</code></pre></p><h3 id="Multiple-30"  >Multiple</h3><b>make-module</b>&nbsp;(name environment &key output-count)<p>Creates a Multiple module. A multiple passes the value of exactly one input socket
   to as many output sockets as defined by output-count.
   <p>The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:output-count The number of output sockets.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
	<li>:input The input signal to be passed to the outputs.</li>
    </ul></p>
    <p>The module has the following outputs:
    <ul>
        <li>:output-1 ... :output-n. Where n is the output-count.</li>
    </ul></p></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-multiple-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-multiple-example-1)

(defun example ()
  "Multiple example"
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment)
               :output-sockets '(:line-out-1 :line-out-2))))
    
    (cl-synthesizer:add-module
     rack "LFO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 1.0 :v-peak 1.0)
    
    (cl-synthesizer:add-module rack "MULTIPLE"
                               #'cl-synthesizer-modules-multiple:make-module :output-count 5)
    (cl-synthesizer:add-patch rack "LFO" :sine "MULTIPLE" :input)
    (cl-synthesizer:add-patch rack "MULTIPLE" :output-1 "OUTPUT" :line-out-1)
    (cl-synthesizer:add-patch rack "MULTIPLE" :output-2 "OUTPUT" :line-out-2)

    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 10)))

;; (run-example)</code></pre></p><h3 id="MIDI Polyphonic Interface-31"  >MIDI Polyphonic Interface</h3><b>make-module</b>&nbsp;(name environment &key (voice-count 1) (channel nil) (note-number-to-cv nil)
 (cv-gate-on 5.0) (cv-gate-off 0.0) (cv-velocity-max 5.0))<p>Creates a polyphonic MIDI interface module. The module dispatches MIDI-Note events to so called voices where each
    voice is represented by a pitch-control voltage, a velocity-control voltage and a gate signal.
    <p>The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:voice-count The number of voices to be exposed by the module.</li>
	<li>:channel Optional MIDI channel to which note events must belong. By default the
	    channel is ignored.</li>
	<li>:note-number-to-cv An optional function that is called with a MIDI note number
	    and returns a control-voltage. The default implementation is cv = note-number / 12.0</li>
	<li>:cv-gate-on The "Gate on" control voltage.</li>
	<li>:cv-gate-off The "Gate off" control voltage.</li>
	<li>:cv-velocity-max Control voltage that represents the maximum velocity of 127.</li>
    </ul>
    Gate transitions are implemented as follows: Each incoming "note on" event causes that the gate signal of the
    assigned voice switches to On. If the gate signal of the assigned voice is already On
    (this happens when the available voices are exhausted and a voice is "stolen") then
    the gate signal switches to Off for the duration of one system tick and then to On again.</p>
    <p>The module has the following inputs:
    <ul>
	<li>:midi-events A list of MIDI events.</li>
    </ul></p>
    <p>The module has the following outputs:
    <ul>
	<li>:gate-1 ... :gate-n Gate signal.</li>
	<li>:cv-1 ... :cv-n Pitch control voltage.</li>
	<li>:velocity-1 ... :velocity-n Velocity control voltage.</li>
    </ul></p></p><h3 id="MIDI Monophonic Interface-32"  >MIDI Monophonic Interface</h3><b>make-module</b>&nbsp;(name environment &key (channel nil) (note-number-to-cv nil) (cv-gate-on 5.0)
 (cv-gate-off 0.0) (force-gate-retrigger nil) (stack-depth 5)
 (cv-velocity-max 5.0) (force-velocity-update nil))<p>Creates a monophonic MIDI interface module. The module dispatches MIDI-Note events to a single voice. 
   If the voice is already assigned to a note, then the incoming note is pushed on top of the current note.
   <p>The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
        <li>:stack-depth Maximum number of stacked notes.</li>
	<li>:channel Optional MIDI channel to which note events must belong. By default the
	    channel is ignored.</li>
	<li>:note-number-to-cv An optional function that is called with a MIDI note number
	    and returns a control-voltage. The default implementation is cv = note-number / 12.0</li>
	<li>:cv-gate-on The "Gate on" control voltage.</li>
	<li>:cv-gate-off The "Gate off" control voltage.</li>
	<li>:force-gate-retrigger If t then each "note on" event will cause a retriggering 
            of the gate signal. Otherwise the gate signal will stay on when it is already on.</li>
	<li>:cv-velocity-max Control voltage that represents the maximum velocity (Velocity = 127).</li>
	<li>:force-velocity-update If t then each "note on" event will cause an
            update of the velocity control voltage according to the velocity of the current event.</li>
    </ul>
    Gate transitions are implemented as follows: Incoming notes are stacked. The 
    first ("initiating") "note on" event causes the gate signal to go up. The gate goes 
    down when after a "note off" event no more notes are on the stack.</p>
    <p>The module has the following inputs:
    <ul>
	<li>:midi-events A list of MIDI events.</li>
    </ul></p>
    <p>The module has the following outputs:
    <ul>
	<li>:gate The gate signal.</li>
	<li>:cv Pitch control voltage representing the note which is on top of the note stack.</li>
	<li>:velocity Velocity control voltage. The velocity control voltage represents 
        the velocity of the initiating "note on" event (Gate goes up). Nested "note on" 
        events do not cause an update of this voltage. This behaviour can be overridden 
        by the :force-velocity-update argument.</li>
    </ul></p></p><h3 id="MIDI CC Interface-33"  >MIDI CC Interface</h3><b>make-module</b>&nbsp;(name environment &key controller-numbers transform-handler (channel nil)
 (initial-output 0) (min-output nil) (max-output nil))<p>Creates a MIDI CC Event interface module. The module maps MIDI control change events to
   an output value. <p>The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:controller-numbers A list of MIDI controller numbers.</li>
        <li>:transform-handler A function that converts a control value to 
            the output value of the module. It is called for each 
            matching CC event and has the following arguments:
            <ul>
                <li>The current output value of the module.</li>
                <li>Controller number.</li>
                <li>Control value.</li>
            </ul>
            <p>The function must return the new output value of the module.</p>
        </li>
        <li>:channel Optional number of the MIDI channel to which the controller events 
          must belong. By default there is no channel filtering applied.</li>
        <li>:initial-output The initial output value of the module.</li>
        <li>:min-output Optional lowest numeric output value of the module. If
        the transform handler returns a number smaller than min-output then
        the actual output-value is set to min-output.</li>
        <li>:max-output Optional largest numeric output value of the module. If
          the transform handler returns a number greater than max-output then
          the actual output value is set to max-output.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
	<li>:midi-events A list of MIDI events.</li>
    </ul></p>
    <p>The module has the following outputs:
    <ul>
	<li>:output The current output value.</li>
    </ul></p></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-midi-cc-interface-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-midi-cc-interface-example-1)

(defun example ()
  "MIDI CC-Interface Example"
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment)
               :input-sockets '(:midi-events))))

    (cl-synthesizer:add-module
     rack "MIDI-CC-IFC" #'cl-synthesizer-modules-midi-cc-interface:make-module
     :controller-numbers '(112)
     :initial-output 2.5
     :min-output 0.0
     :max-output 5.0
     :transform-handler
     (lambda (cur-output controller-number control-value)
       (declare (ignore controller-number))
       (cond
         ((= control-value 61)
          (+ cur-output -0.5))
         ((= control-value 67)
          (+ cur-output 0.5))
         (t cur-output)))
     :channel nil)
    
    (cl-synthesizer:add-patch rack "INPUT" :midi-events "MIDI-CC-IFC" :midi-events)

    rack))

(defun run-example ()
  (cl-synthesizer::play-rack (example) :duration-seconds 5))

;; (run-example)</code></pre></p><h3 id="MIDI Sequencer-34"  >MIDI Sequencer</h3><b>make-module</b>&nbsp;(name environment &key events)<p>Creates a Midi-Sequencer module.
    <p>The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:events A list of Midi events and their timestamps. Each
	    entry consists of a property list with the following keys:
	    <ul>
		<li>:timestamp-milli-seconds Point of time when events are to be fired. The very first
                timestamp of the synthesizer is 0.</li>
		<li>:midi-events List of Midi events to be fired.</li>
	    </ul>
            The events must be ordered by timestamp and there must be no duplicate timestamps. 
	</li>
    </ul></p>
    The module has no inputs.
    The module has one output socket :midi-events.</p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-midi-sequencer-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-midi-sequencer-example-1)

(defun example ()
  "Midi-Sequencer example"
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment)
               :output-sockets '(:line-out))))

    ;; Add sequencer
    (cl-synthesizer:add-module
     rack
     "MIDI-SEQUENCER"
     #'cl-synthesizer-modules-midi-sequencer:make-module :events
     (list 
      (list :timestamp-milli-seconds 0
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-on-event 1 69 100)))
      (list :timestamp-milli-seconds 1000
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-off-event 1 69 100)))
      (list :timestamp-milli-seconds 2000
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-on-event 1 75 100)))
      (list :timestamp-milli-seconds 2500
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-off-event 1 75 100)))))

    ;; Add MIDI Interface and connect it with the MIDI Sequencer
    (cl-synthesizer:add-module
     rack
     "MIDI-IFC"
     #'cl-synthesizer-modules-midi-polyphonic-interface:make-module :voice-count 1)
    (cl-synthesizer:add-patch rack "MIDI-SEQUENCER" :midi-events "MIDI-IFC" :midi-events)

    ;; Add VCO
    (cl-synthesizer:add-module
     rack "VCO" #'cl-synthesizer-modules-vco:make-module
     :base-frequency (cl-synthesizer-midi:get-note-number-frequency 0)
     :v-peak 5.0)

    ;; Add ADSR
    (cl-synthesizer:add-module
     rack "ADSR"
     #'cl-synthesizer-modules-adsr:make-module
     :attack-time-ms 100 :attack-target-output 5.0
     :decay-time-ms 50 :decay-target-output 3.0
     :release-time-ms 100)
    
    ;; Add VCA
    (cl-synthesizer:add-module rack "VCA" #'cl-synthesizer-modules-vca:make-module :cv-max 5.0 :exponential nil)

    ;; Connect VCA with ADSR and VCO
    (cl-synthesizer:add-patch rack "VCA" :output "OUTPUT" :line-out)
    (cl-synthesizer:add-patch rack "ADSR" :cv "VCA" :cv)
    (cl-synthesizer:add-patch rack "VCO" :triangle "VCA" :input)
    
    ;; Connect Midi interface with ADSR and VCO
    (cl-synthesizer:add-patch rack "MIDI-IFC" :cv-1 "VCO" :cv-exp)
    (cl-synthesizer:add-patch rack "MIDI-IFC" :gate-1 "ADSR" :gate)

    ;; Record LINE-OUT into a wave file
    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-wave-handler:make-backend
     '(("OUTPUT" :input-socket :line-out))
     :filename "cl-synthesizer-examples/midi-sequencer-example-1.wav")
    
    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer::play-rack rack :duration-seconds 5)))

;; (run-example)</code></pre></p><h3 id="Fixed Output-35"  >Fixed Output</h3><b>make-module</b>&nbsp;(name environment &key value (output-socket out))<p>Creates a module with a fixed output value.
   <p>The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:value The value of the module output.</li>
	<li>:output-socket Optional keyword that declares the output socket
	    identifier to be exposed by the module.</li>
    </ul></p>
    The module has no inputs.
    The module has one output socket according to the :output-socket argument.</p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-fixed-output-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-fixed-output-example-1)

(defun example ()
  "Fixed-Output example"
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment)
               :output-sockets '(:line-out))))
    
    (cl-synthesizer:add-module
     rack "FIXED-OUTPUT"
     #'cl-synthesizer-modules-fixed-output:make-module
     :value 3.0
     :output-socket :fixed)
    
    (cl-synthesizer:add-patch rack "FIXED-OUTPUT" :fixed "OUTPUT" :line-out)

    rack))

(defun run-example ()
  (cl-synthesizer:play-rack (example) :duration-seconds 1))

;; (run-example)</code></pre></p><h3 id="Adder-36"  >Adder</h3><b>make-module</b>&nbsp;(name environment &key input-count)<p>Creates a simple voltage adder module. 
   <p>The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:input-count The number of input sockets.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
        <li>:input-1 ... :input-n. Where n is the input-count. Input values
        not of type <b>number</b> are ignored.</li>
    </ul></p>
    <p>The module has the following outputs:
    <ul>
	<li>:output The output consisting of the sum of the inputs.</li>
    </ul></p></p><h3 id="Mixer-37"  >Mixer</h3><b>make-module</b>&nbsp;(name environment &key channel-count (channel-cv-max 5.0) (channel-cv-gain 5.0)
 (main-cv-max 5.0) (main-cv-gain 5.0))<p>Creates a mixer module. The mixer provides an attenuator for each input and a main
   attenuator for the mixer output. All attenuators have linear amplification
   characteristic. <p>The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:channel-count The number of channels.</li>
        <li>:channel-cv-max The value of a channel attenuation control voltage that 
        represents an amplification of 1.0.</li>
        <li>:channel-cv-gain An offset that is added to the channel attenuation 
        control voltage.</li>
        <li>:main-cv-max The value of the main attenuation input that 
        represents an amplification of 1.0.</li>
        <li>:main-cv-gain An offset that is added to the main attenuation 
        control voltage.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
        <li>:channel-1 ... :channel-n. Channel input signal, where n is the channel-count.</li>
        <li>:cv-1 ... :cv-n. Channel attenuation control voltage, where n is the channel-count.</li>
        <li>:cv-main Attenuation control voltage of the mixer output.</li> 
    </ul></p>
    <p>The module has the following outputs:
    <ul>
	<li>:output The output consisting of the sum of the inputs.</li>
    </ul></p></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-mixer-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-mixer-example-1)

(defun example ()
  "Mixer example."
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment)
               :output-sockets '(:line-out))))

    ;;
    ;; add modules...
    ;;
    
    (cl-synthesizer:add-module
     rack "MIXER" #'cl-synthesizer-modules-mixer:make-module
     :channel-count 2
     :channel-cv-max 5.0
     :channel-cv-gain 5.0
     :main-cv-max 5.0
     :main-cv-gain 2.5)
    
    (cl-synthesizer:add-patch rack "VOICE-1" :audio "MIXER" :channel-1)
    (cl-synthesizer:add-patch rack "VOICE-2" :audio "MIXER" :channel-2)
    (cl-synthesizer:add-patch rack "MIXER" :output "OUTPUT" :line-out)
    
    rack))</code></pre></p><h3 id="Trigger-38"  >Trigger</h3><b>make-module</b>&nbsp;(name environment &key trigger-threshold pulse-voltage)<p>Creates a Voltage to Trigger Converter module. 
   The module fires a one clock cycle long pulse when input voltage >= trigger-threshold
   and then waits that the input voltage descends below trigger-threshold before the next
   pulse can be triggered. The module can for example be used to generate a trigger
   out of a gate signal. <p>The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:trigger-threshold The minimum value of the input which triggers a pulse.</li>
	<li>:pulse-voltage The voltage of the pulse.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
	<li>:input The input voltage.</li>
    </ul></p>
    <p>The module has the following outputs:
    <ul>
        <li>:output The output voltage (zero or pulse-voltage).</li>
    </ul></p></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-trigger-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-trigger-example-1)

(defun example ()
  "Emit trigger signal based on sine input"
  (let ((rack (cl-synthesizer:make-rack :environment (cl-synthesizer:make-environment))))
    (cl-synthesizer:add-module
     rack
     "VCO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 5.0 :v-peak 5.0)

    (cl-synthesizer:add-module
     rack
     "TRIGGER"
     #'cl-synthesizer-modules-trigger:make-module
     :trigger-threshold 4.9 :pulse-voltage 3.0)

    (cl-synthesizer:add-patch rack "VCO" :sine "TRIGGER" :input)
    
    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-wave-handler:make-backend
     '(("TRIGGER" :input-socket :input)
       ("TRIGGER" :output-socket :output))
     :filename "cl-synthesizer-examples/trigger-example-1.wav")

    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 2)))

;; (run-example)</code></pre></p><h3 id="Ramp-39"  >Ramp</h3><b>make-module</b>&nbsp;(name environment &key time-ms target-output (gate-state nil)
 (trigger-threshold 2.5) (gate-threshold 2.5) (time-cv-to-time-ms nil)
 (exponential nil))<p>Creates a module whose output climbs from a given input value to a given output value
    in a given time. Main purpose of this module is to create envelope generators by chaining
    multiple ramp and sustain modules. <p>The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:time-ms Default climbing time (duration) in milliseconds.</li>
	<li>:target-output Desired target output value. Due to the time resolution given by the sample-rate 
	    of the environment the ramp may stop at an output value a little bit smaller or 
	    greater than the desired target-output value.</li>
	<li>:gate-state Required state of the Gate input. One of :on, :off, nil</li>
	<li>:trigger-threshold Minimum value of the :trigger input that indicates that the trigger is active.</li>
	<li>:gate-threshold Minimum value of the :gate input that indicates that the gate is on.</li>
	<li>:time-cv-to-time-ms An optional function that converts a time control voltage to a duration in milliseconds.
        The default implementation is 1000ms/1V (abs(cv-time) * 1000).</li>
        <li>:exponential If t then the ramp will climb with an exponential characteristic.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
	<li>:trigger Trigger input. If the trigger is active (see also :trigger-threshold), the module samples
	    its current input value and begins climbing to the desired target output value.</li>
	<li>:input Input value.</li>
	<li>:pass-through If value is >= 5.0 the module passes through its input value.</li>
	<li>:gate A gate signal (see also :gate-threshold).</li>
	<li>:cv-time NIL or climbing time (duration) of the ramp (see also :time-cv-to-time-ms).</li>
    </ul></p>
    <p>The module has the following outputs:
    <ul>
	<li>:output Output value of the module. The initial output value is 0.0.</li>
	<li>:busy A value >= 5.0 indicates that the module is busy by either passing through
	its input value or climbing to the target output value.</li>
	<li>:done A trigger signal that jumps to 5.0 for the length of one clock cycle when the ramp has
	finished.</li>
	<li>:gate Passed through :gate input. Purpose of this output is to support more convenient
	    chaining of ramp and sustain modules.</li>
    </ul></p>
    When the ramp aborts due to a toggling Gate signal or when its supposed
    duration has been exceeded due to time modulation then the output value does not jump 
    to the desired target-output but stays at its current value.<br><br>
    This module has been inspired by <a href="https://github.com/dhemery/DHE-Modules/wiki/Multi-Stage-Envelopes">dhemery</a></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-ramp-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-ramp-example-1)

(defun make-voice (name environment &amp;key (exponential nil))
  (declare (ignore name))
  (let ((rack
         (cl-synthesizer:make-rack
          :environment environment
          :input-sockets '(:trigger)
          :output-sockets '(:output))))

    (cl-synthesizer:add-module
     rack "ATTACK"
     #'cl-synthesizer-modules-ramp:make-module
     :time-ms 700 :target-output 5.0 :gate-state nil :exponential exponential)

    (cl-synthesizer:add-module
     rack "DECAY"
     #'cl-synthesizer-modules-ramp:make-module
     :time-ms 500 :target-output -2.5 :exponential exponential)
    
    (cl-synthesizer:add-patch rack "INPUT" :trigger "ATTACK" :trigger)
    (cl-synthesizer:add-patch rack "ATTACK" :busy "DECAY" :pass-through)
    (cl-synthesizer:add-patch rack "ATTACK" :output "DECAY" :input)
    (cl-synthesizer:add-patch rack "ATTACK" :done "DECAY" :trigger)

    (cl-synthesizer:add-patch rack "DECAY" :output "OUTPUT" :output)

    rack))

(defun example ()
  "Linear and Exponential Ramp"
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment))))

    (cl-synthesizer:add-module
     rack "VCO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 0.5 :v-peak 5.0)

    (cl-synthesizer:add-module
     rack "TRIGGER"
     #'cl-synthesizer-modules-trigger:make-module
     :trigger-threshold 4.9 :pulse-voltage 5.0)

    (cl-synthesizer:add-patch rack "VCO" :square "TRIGGER" :input)
    
    (cl-synthesizer:add-module
     rack "TRIGGER-MULTIPLE"
     #'cl-synthesizer-modules-multiple:make-module
     :output-count 2)

    (cl-synthesizer:add-patch rack "TRIGGER" :output "TRIGGER-MULTIPLE" :input)
    
    (cl-synthesizer:add-module
     rack "LINEAR" #'make-voice :exponential nil)
    (cl-synthesizer:add-patch rack "TRIGGER-MULTIPLE" :output-1 "LINEAR" :trigger)
    
    (cl-synthesizer:add-module
     rack "EXPONENTIAL" #'make-voice :exponential t)
    (cl-synthesizer:add-patch rack "TRIGGER-MULTIPLE" :output-2 "EXPONENTIAL" :trigger)

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-csv-handler:make-backend
     '(("LINEAR" :output-socket :output :name "Lin Out")
       ("EXPONENTIAL" :output-socket :output :name "Exp Out"))
     :filename "cl-synthesizer-examples/ramp-example-1.csv")
    
    rack))

(defun run-example ()
  (let ((rack (example))) (cl-synthesizer:play-rack rack :duration-seconds 5)))

;; (run-example)</code></pre></p><h3 id="Sustain-40"  >Sustain</h3><b>make-module</b>&nbsp;(name environment &key (trigger-threshold 2.5) (gate-threshold 2.5))<p>Creates a module which holds a given input as long as its gate input is "on".
    Main purpose of this module is to create envelope generators by chaining
    multiple ramp and sustain modules. <p>The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:trigger-threshold Minimum value of the :trigger input that indicates that the trigger is active.</li>
	<li>:gate-threshold Minimum value of the :gate input that indicates that the gate is on.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
	<li>:trigger Trigger input. If the trigger is active (see also :trigger-threshold), the module samples
	    its current input value and begins passing it to its output socket.</li>
	<li>:input Input value.</li>
	<li>:pass-through If value is >= 5.0 the module passes through its input value.</li>
	<li>:gate A gate signal (see also :gate-threshold).</li>
    </ul></p>
    <p>The module has the following outputs:
    <ul>
	<li>:output Output value of the module. The initial output value is 0.0.</li>
	<li>:busy A value >= 5.0 indicates that the module is busy by either passing through
	    its input value or holding the sampled input value until the gate input falls to zero.</li>
	<li>:done A trigger signal that jumps to 5.0 for the length of one clock cycle when the sustain cycle
	    has finished.</li>
	<li>:gate Passed through :gate input. Purpose of this output is to support more convenient
	    chaining of ramp and sustain modules.</li>
    </ul></p>
    This module has been inspired by <a href="https://github.com/dhemery/DHE-Modules/wiki/Multi-Stage-Envelopes">dhemery</a></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-sustain-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-sustain-example-1)

(defun example ()
  "Sustain example"
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment))))
    
    ;; Use MIDI sequencer for generation of Gate signals
    (cl-synthesizer:add-module
     rack "MIDI-SEQUENCER"
     #'cl-synthesizer-modules-midi-sequencer:make-module :events
     (list 
      (list :timestamp-milli-seconds 300
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-on-event 1 69 100)))
      (list :timestamp-milli-seconds 700
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-off-event 1 69 100)))
      (list :timestamp-milli-seconds 1800
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-on-event 1 69 100)))
      (list :timestamp-milli-seconds 2100
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-off-event 1 69 100)))))

    (cl-synthesizer:add-module
     rack "MIDI-IFC"
     #'cl-synthesizer-modules-midi-polyphonic-interface:make-module :voice-count 1)

    (cl-synthesizer:add-module
     rack "GATE-MULTIPLE"
     #'cl-synthesizer-modules-multiple:make-module :output-count 2)

    (cl-synthesizer:add-module
     rack "TRIGGER"
     #'cl-synthesizer-modules-trigger:make-module
     :trigger-threshold 4.9 :pulse-voltage 5.0)

    (cl-synthesizer:add-module
     rack "VCO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 0.5 :v-peak 5.0)
    
    (cl-synthesizer:add-module
     rack "SUSTAIN"
     #'cl-synthesizer-modules-sustain:make-module)

    (cl-synthesizer:add-patch rack "MIDI-SEQUENCER" :midi-events "MIDI-IFC" :midi-events)
    (cl-synthesizer:add-patch rack "MIDI-IFC" :gate-1 "GATE-MULTIPLE" :input)
    (cl-synthesizer:add-patch rack "GATE-MULTIPLE" :output-1 "TRIGGER" :input)
    (cl-synthesizer:add-patch rack "GATE-MULTIPLE" :output-2 "SUSTAIN" :gate)
    (cl-synthesizer:add-patch rack "TRIGGER" :output "SUSTAIN" :trigger)
    (cl-synthesizer:add-patch rack "VCO" :sine "SUSTAIN" :input)

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-csv-handler:make-backend
     '(("MIDI-IFC" :output-socket :gate-1 :name "Gate")
       ("SUSTAIN" :input-socket :trigger :name "Sustain Trigger In")
       ("SUSTAIN" :input-socket :input :name "Sustain In")
       ("SUSTAIN" :output-socket :output :name "Sustain Out")
       ("SUSTAIN" :output-socket :done :name "Sustain Done Out"))
     :filename "cl-synthesizer-examples/sustain-example-1.csv")
    
    rack))

(defun run-example ()
  (let ((rack (example))) (cl-synthesizer:play-rack rack :duration-seconds 3)))

;; (run-example)</code></pre></p><h3 id="Wave File Writer-41"  >Wave File Writer</h3><b>make-module</b>&nbsp;(name environment &key channel-count filename (v-peak 5.0) (sample-width 16bit))<p>Creates a Wave File Writer module. Writes files in "Waveform Audio File" ("WAV") format.
    <p>The function has the following arguments:
  <ul>
    <li>name Name of the writer.</li>
    <li>environment The synthesizer environment.</li>
    <li>:channel-count Number of channels.</li>
    <li>:filename The relative path of the file to be written. The filename will be concatenated
        with the base path as defined by the :home-directory property of the environment.</li>
    <li>:v-peak Optional peak voltage. The inputs of the module will be scaled
	to v-peak. If for example v-peak is set to 20.0 an incoming voltage
	of 5.0 results in a sample value (which is written into the wave file)  
        of 5.0 / 20.0 -> 0.25 and an incoming voltage of -5.0 results in a sample 
        value of -0.25. The default value is 5.0. Incoming voltages will be clipped 
        according to v-peak.</li>
    <li>:sample-width Resolution of samples. One of :8Bit, :16Bit, :24Bit</li> 
  </ul></p>
  <p>The module has the following inputs:
  <ul>
      <li>:channel-1 ... :channel-n The sample values of the generated frames
	  are written in order :channel-1 ... :channel-n</li>
  </ul></p>
  The module has no outputs.
  <p>The recommended way of Wave file generation is to use a Monitor.</p></p><h3 id="CSV File Writer-42"  >CSV File Writer</h3><b>make-module</b>&nbsp;(name environment &key columns filename (column-separator ,) (add-header t))<p>Creates a CSV File Writer module.
    <p>The function has the following arguments:
  <ul>
    <li>name Name of the writer.</li>
    <li>environment The synthesizer environment.</li>
    <li>:columns A list of column definitions. Each colum definition consists of a property list 
        with the following keys:
        <ul>
            <li>:name Name of the column.</li>
            <li>:default-value Default value to be used if current column value is nil.</li>
        </ul>
    </li>
    <li>:filename The relative path of the file to be written. The filename will be concatenated
        with the base path as defined by the :home-directory property of the environment.</li>
    <li>:column-separator The column separator.</li>
    <li>:add-header If t then a header consisting of the column-names will be written.</li>
  </ul></p>
  <p>The module has the following inputs:
  <ul>
      <li>:column-1 ... :column-n Where n is the number of columns.</li>
  </ul></p>
  <p>Due to performance/consing considerations all columns are written using the Lisp-Writer. 
     If a value contains the column separator it will not be quoted. The file is opened on the first 
     call of the update function and closed by the shutdown handler.
  </p>
  The module has no outputs.
  <p>The recommended way of CSV file generation is to use a Monitor.</p></p><h2 id="Monitor-43"  >Monitor</h2><h3 id="add-monitor-44"  >add-monitor</h3><b>add-monitor</b>&nbsp;(rack monitor-handler socket-mappings &rest additional-handler-args)<p>Adds a monitor to a rack. <p>The function has the following arguments:
    <ul>
	<li>rack The rack.</li>
	<li>monitor-handler A function that instantiates the monitor backend.
	    This function is called with the following arguments:
	    <ul>
		<li>name A name.</li>
		<li>environment The synthesizer environment.</li>
		<li>inputs A list of inputs. Each entry consists of the additional
                    settings that have been set at a specific socket mapping, for example
                    the CSV formatting string.</li>
		<li>additional-handler-args Any additional keyword parameters as
		    passed to the monitor function. These parameters can be
		    used to initialize handler specific properties such as
		    a filename.</li>
	    </ul>
	    The function must return a values object with the following entries:
	    <ul>
		<li>module A property list that implements a module (this is the Monitor-Backend).</li>
		<li>An ordered list of input sockets of the module (the Monitor-Backend), where the first entry represents 
                   the first entry of the socket mappings (e.g. column-1) and so on.</li>
	    </ul>
	</li>
	<li>socket-mappings Declares the input/outputs/states whose values are to be tracked.
            Each entry has the following format:
	    <ul>
		<li>module-path Path of the module from which the value of
		    a certain input/output socket or state is to be retrieved, for
		    example "ADSR" or '("VOICE-1" "ADSR"). 
                    See also cl-synthesizer:find-module.</li>
		<li>socket-type One of the following keywords: 
                    <ul>
                        <li>:input-socket The value of an input socket of the module.</li>
                        <li>:output-socket The value of an output socket of the module.</li>
                        <li>:state The value of an internal state of the module (see state function).</li>
                    </ul>
                </li>
		<li>socket A keyword that identifies one of the input/output sockets or internal states
		    provided by the module, for example :cv</li>
                <li>Any additional settings. Supported settings depend
                    on the handler that is being used, for example a CSV writer may
                    support a column formatting string.</li>
	    </ul>
	</li>
	<li>&rest additional-handler-args Optional keyword arguments to be passed to
	    the handler instantiation function.</li>
    </ul></p></p><h3 id="wave-handler-45"  >wave-handler</h3><b>make-backend</b>&nbsp;(name environment inputs &rest rest &key filename &allow-other-keys)<p>Creates a monitor backend which writes its inputs into a Wave file.
    <p>The function has the following arguments:
    <ul>
	<li>name A name.</li>
	<li>environment The synthesizer environment.</li>
	<li>inputs The column input settings as provided by the Monitor component.</li>
	<li>:filename A file path relative to the output directory as defined by the environment.</li>
    </ul></p>
    <p>The function returns a values object consisting of
    <ul>
       <li>A property list that implements a module (this is the Monitor-Backend).</li>
       <li>An ordered list of input sockets of the module.</li>
    </ul></p>
    <p>See also cl-synthesizer-modules:wave-file-writer.</p></p><h3 id="csv-handler-46"  >csv-handler</h3><b>make-backend</b>&nbsp;(name environment inputs &rest rest &key filename &allow-other-keys)<p>Creates a monitor backend which writes its inputs into a CSV file.
    <p>The function has the following arguments:
    <ul>
	<li>name A name.</li>
	<li>environment The synthesizer environment.</li>
	<li>inputs The column input settings as provided by the Monitor component.</li>
	<li>:filename A file path relative to the output directory as defined by the environment.</li>
    </ul></p>
    <p>The function returns a values object consisting of
    <ul>
       <li>A property list that implements a module (this is the Monitor-Backend).</li>
       <li>An ordered list of input sockets of the module.</li>
    </ul></p>
    <p>See also cl-synthesizer-modules:csv-file-writer.</p></p><h2 id="MIDI-47"  >MIDI</h2><h3 id="MIDI Event-48"  >MIDI Event</h3><b>make-control-change-event</b>&nbsp;(channel controller-number value)<p>Creates a MIDI control change event.</p><b>make-note-on-event</b>&nbsp;(channel note-number velocity)<p>Creates a MIDI Note-On event.</p><b>make-note-off-event</b>&nbsp;(channel note-number velocity)<p>Creates a MIDI Note-Off event.</p><b>control-change-eventp</b>&nbsp;(event)<p>Returns t if the given MIDI event is a Control-Change event.</p><b>note-on-eventp</b>&nbsp;(event)<p>Returns t if the given MIDI event is a Note-On event.</p><b>note-off-eventp</b>&nbsp;(event)<p>Returns t if the given MIDI event is a Note-Off event.</p><b>get-channel</b>&nbsp;(event)<p>Returns the MIDI channel number to which the event belongs.</p><b>get-controller-number</b>&nbsp;(event)<p>Returns the controller number of a Control-Change MIDI event.</p><b>get-controller-value</b>&nbsp;(event)<p>Returns the controller value of a Control-Change MIDI event.</p><b>get-note-number</b>&nbsp;(event)<p>Returns the note number of Note-On/Off MIDI event.</p><b>get-velocity</b>&nbsp;(event)<p>Returns the velocity of a Note-On/Off MIDI event.</p><h3 id="MIDI Utilities-49"  >MIDI Utilities</h3><b>get-note-number-frequency</b>&nbsp;(note-number)<p>Returns the frequency of a given note number. Note number 69 results in a frequency of 440Hz.
   This function implements a mapping according to 
   <a href="http://subsynth.sourceforge.net/midinote2freq.html">midinote2freq</a></p><h2 id="Conditions-50"  >Conditions</h2><b>assembly-error</b><p>This condition is signalled in cases where the assembly of a rack fails,
   because for example a module name is not unique, a patch is added for
   a non-existing module, a patch is added to an already patched socket
   and so on.</p><h1 id="Acknowledgements-51"  >Acknowledgements</h1><ul>
<li>Envelope generation has been inspired by <a href="https://github.com/dhemery/DHE-Modules/wiki/Multi-Stage-Envelopes">dhemery</a></li>
</ul></section><footer  ><p><small>Generated 2020-10-10  00:28:57</small></p></footer></body></html>