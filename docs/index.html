<html><head><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:300,300italic,700,700italic"><link rel="stylesheet" href="//cdn.rawgit.com/necolas/normalize.css/master/normalize.css"><link rel="stylesheet" href="//cdn.rawgit.com/milligram/milligram/master/dist/milligram.min.css"></head><body><section class="container"><h1>cl-synthesizer</h1><p>A Modular Audio Synthesizer library implemented in Common Lisp.</p><p><b>Example:</b></p><p><pre><code>(defpackage :cl-synthesizer-rack-example-1
  (:use :cl))

(in-package :cl-synthesizer-rack-example-1)

(defun make-voice (name environment &amp;key lfo-frequency vco-frequency)
  "Frequency modulated saw"
  (declare (ignore name))
  (let ((voice
         (cl-synthesizer:make-rack
          :environment environment
          ;; Expose audio output socket
          :output-sockets '(:audio))))
    
    (cl-synthesizer:add-module
     voice "LFO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency lfo-frequency :v-peak 0.1 :f-max 500.0 :cv-max 5.0)

    (cl-synthesizer:add-module
     voice "VCO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency vco-frequency :f-max 5000.0 :v-peak 5.0 :cv-max 5.0)

    (cl-synthesizer:add-patch voice "LFO" :sine "VCO" :cv-lin)
    (cl-synthesizer:add-patch voice "VCO" :saw "OUTPUT" :audio)
    
    voice))
  
(defun example ()
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment)
               ;; Expose line-out sockets
               :output-sockets '(:left :right))))

    (cl-synthesizer:add-module
     rack "VOICE-1" #'make-voice :lfo-frequency 1.0 :vco-frequency 440.0)
    (cl-synthesizer:add-module
     rack "VOICE-2" #'make-voice :lfo-frequency 2.0 :vco-frequency 442.0)

    (cl-synthesizer:add-patch rack "VOICE-1" :audio "OUTPUT" :left)
    (cl-synthesizer:add-patch rack "VOICE-2" :audio "OUTPUT" :right)

    ;; Generate a Wave-File
    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-wave-handler:make-handler
     '(("OUTPUT" :input-socket :left)
       ("OUTPUT" :input-socket :right))
     :filename "rack-example-1.wav")
    
    rack))

(defun run-example ()
  (cl-synthesizer:play-rack (example) :duration-seconds 5))
  
;;(run-example)</code></pre></p><h2>Installation</h2><pre><code>cd ~/quicklisp/local-projects
git clone https://github.com/Frechmatz/cl-wave-file-writer.git
git clone https://github.com/Frechmatz/cl-synthesizer.git
(ql:quickload "cl-synthesizer")</code></pre></section><nav class="container"><h2>API Reference</h2><ul><li><a href="#environment">Environment</a></li><li><a href="#rack">Rack</a></li><li><a href="#modules">Modules</a><ul><li><a href="#vco">VCO</a></li><li><a href="#vca">VCA</a></li><li><a href="#adsr">ADSR</a></li><li><a href="#multiple">Multiple</a></li><li><a href="#midi-interface">MIDI Interface</a></li><li><a href="#midi-cc-interface">MIDI CC Interface</a></li><li><a href="#midi-sequencer">MIDI Sequencer</a></li><li><a href="#fixed-output">Fixed Output</a></li><li><a href="#adder">Adder</a></li><li><a href="#mixer">Mixer</a></li><li><a href="#trigger">Trigger</a></li><li><a href="#ramp">Ramp</a></li><li><a href="#sustain">Sustain</a></li><li><a href="#wave-file-writer">Wave File Writer</a></li><li><a href="#csv-file-writer">CSV File Writer</a></li></ul></li><li><a href="#monitor">Monitor</a></li><li><a href="#midi">MIDI</a><ul><li><a href="#midi-event">MIDI Event</a></li><li><a href="#midi-utilities">MIDI Utilities</a></li></ul></li><li><a href="#conditions">Conditions</a></li></ul></nav><section class="container"><h3 id="environment">Environment</h3><p><b>cl-synthesizer:make-environment</b> &key (sample-rate 44100) (home-directory nil) </p><p>Creates an environment. The environment defines properties such as
    the sample rate of the rack.
    An enviroment is a property list with the following keys:
    <ul>
	<li>:sample-rate Sample rate of the synthesizer.</li>
	<li>:home-directory The base output directory for wave files etc. Default value is the home directory
        of the current user.</li>
    </ul></p></section><section class="container"><h3 id="rack">Rack</h3><p><b>cl-synthesizer:make-rack</b> &key environment (input-sockets nil) (output-sockets nil) </p><p>Creates a rack. A rack is a module container as well as a module. Racks can
   be added to other racks. The function has the following arguments:
    <ul>
	<li>:environment The synthesizer environment.</li>
        <li>:input-sockets The input sockets to be exposed by the rack. The inputs
        can be patched with other modules via the bridge module "INPUT".</li>
        <li>:output-sockets The output sockets to be exposed by the rack. The outputs
        can be patched with other modules via the bridge module "OUTPUT".</li>
    </ul>
    <p>    
    The update function calls the update function of all modules. If the 
    rack has already been shut down the function immediately returns <b>nil</b>.
    Othwerwise it returns <b>t</b>.
    </p><p>
    The shutdown function calls the shutdown handlers of all modules and hooks. If the rack has 
    already been shut down the function immediately returns.
    </p>
    <p>See also: add-module</p></p><hr/><p><b>cl-synthesizer:is-rack</b> module </p><p>Returns <b>t</b> if the given module represents a rack.</p><hr/><p><b>cl-synthesizer:add-module</b> rack module-name module-fn &rest args </p><p>Adds a module to a rack. The function has the following arguments:
    <ul>
	<li>rack The rack.</li>
	<li>module-name Unique name of the module, for example "VCO-1". If the name
	    is already used by another module an assembly-error is signalled.</li>
	<li>module-fn A function that instantiates the module. This function is
	    called by the rack with the following arguments:
	    <ul>
		<li>name Name of the module.</li>
		<li>environment The synthesizer environment.</li>
		<li>module-args Any additional arguments passed to add-module.</li>
	    </ul>
	    The module instantiation function must return a property list with the following keys:
	    <ul>
		<li>:inputs A function with no arguments that returns a property list representing the
                    input sockets and their corresponding setter functions that are exposed by the module.</br>
                    Example: <code>:inputs (lambda() (list :input-1 (lambda(value) (setf input-1 value))))</code>
                    </br>Modules are supposed to buffer this list as the inputs might be requested several times.
                </li>
		<li>:outputs A function with no arguments that returns a property list representing 
                    the  output sockets and their corresponding getter functions that exposed by the module.</br>
                    Example: <code>:outputs (lambda() (list :output-1 (lambda() output-1)))</code>
                    </br>Modules are supposed to buffer this list as the outputs might be requested several times.
                </li>
		<li>:update A function with no arguments that updates the outputs according to the previously set inputs.</li>
		<li>:shutdown An optional function with no arguments that is called when the rack
		    is shutting down.</li>
                <li>:get-state An optional function that can be used to expose internal states 
                    of the module, for example a VCO may expose its frequency. The function has one 
                    argument that consists of a keyword identifying the requested state, for 
                    example :frequency.</li>
	    </ul>
	</li>
	<li>&rest args Arbitrary additional arguments to be passed to the module instantiation function.
	    These arguments typically consist of keyword parameters.</li>
    </ul>
    Returns the module.</p><hr/><p><b>cl-synthesizer:add-patch</b> rack output-module-name output-socket input-module-name input-socket </p><p>Adds a patch to the rack. A patch is an unidirectional connection between an output socket
    of a source module and an input socket of a destination module. The rack supports cycles 
    which means that an output socket of a module can be patched with one of its inputs (typically via
    multiple hops through other modules). The function has the following arguments:
    <ul>
	<li>rack The rack.</li>
	<li>output-module-name Name of the output (source) module.</li>
	<li>output-socket A keyword representing one of the output sockets of the
	    output module.</li>
	<li>input-module-name Name of the input (destination) module.</li>
	<li>input-socket A keyword representing one of the input sockets of the
	    input module.</li>
    </ul>
    The rack signals an assembly-error in the following cases:
    <ul>
	<li>A module with the given output name does not exist.</li>
	<li>A module with the given input name does not exist.</li>
	<li>The given output-socket is already connected with a module.</li>
	<li>The given output-socket is not exposed by the output module.</li>
	<li>The given input-socket is already connected with a module.</li>
	<li>The given input-socket is not exposed by the input module.</li>
    </ul></p><hr/><p><b>cl-synthesizer:get-module</b> rack name </p><p>Get a module of a rack. The function has the following arguments:
    <ul>
      <li>rack The rack.</li>
      <li>name The name of the module.</li>
    </ul>
   Returns the module or nil.</p><hr/><p><b>cl-synthesizer:get-module-name</b> rack module </p><p>Get the name of a module. The function has the following arguments:
    <ul>
	<li>rack The rack.</li>
	<li>module The module.</li>
    </ul>
   Returns the name or nil if the module does not belong to the rack</p><hr/><p><b>cl-synthesizer:find-module</b> rack module-path </p><p>Get a module of a rack. The function has the following arguments:
    <ul>
      <li>rack The root rack.</li>
      <li>module-path The path of the module within the rack (through multiple nested racks).</br>
         Example 1: "VCO"</br> 
         Example 2: '("VOICE-1" "VCO")</li>
    </ul>
   Returns nil or a values object consisting of the rack of the module, the module name and the module itself.</p><hr/><p><b>cl-synthesizer:get-patches</b> rack </p><p>Get all patches of a rack. The function has the following arguments:
    <ul>
	<li>rack The rack.</li>
    </ul>
   Returns a list of property lists with the following keys:
   <ul>
     <li>:output-name Name of the output module.</li>
     <li>:output-socket Output socket. </li>
     <li>:input-name Name of the input module. </li>
     <li>:input-socket Input socket.</li>
   </ul></p><hr/><p><b>cl-synthesizer:get-modules</b> rack </p><p>Get all modules of a rack. The function has the following arguments:
    <ul>
	<li>rack The rack.</li>
    </ul>
    Returns a list of modules where each module consists of a property list with
    the following keys:
    <ul>
       <li>:module The module</li>
       <li>:name Name of the module</li>
    </ul></p><hr/><p><b>cl-synthesizer:play-rack</b> rack &key duration-seconds </p><p>A utility function that "plays" the rack by consecutively calling its update function
    for a given number of "ticks". The function has the following arguments:
    <ul>
	<li>rack The rack.</li>
	<li>:duration-seconds Duration in seconds of how long to play the rack. If for
	    example the duration is 2 seconds and the sample rate of the rack as declared
	    by its environment is 44100, then the update function of the rack will be called 88200 times.</li>
    </ul></p><hr/><p><b>cl-synthesizer:get-environment</b> rack </p><p>Returns the environment of the rack.</p><hr/><p><b>cl-synthesizer:add-hook</b> rack hook </p><p>Adds a hook to the rack. A hook is called each time after the rack has updated its state.
   A hook consists a property list with the following keys:
   <ul>
      <li>:update A function with no arguments that is called after the rack has updated its state.</li>
      <li>:shutdown A function with no arguments that is called when the rack is shutting down.</li>
   </ul>
   Hooks must not modify the rack. See also <b>cl-synthesizer-monitor:add-monitor</b>.</p></section><section class="container"><h3 id="modules">Modules</h3><h4 id="vco">VCO</h4><p><b>cl-synthesizer-modules-vco:make-module</b> name environment &key base-frequency f-max v-peak cv-max (duty-cycle 0.5) (phase-offset 0.0) </p><p>Creates a Voltage Controlled Oscillator module with 1V/Octave and linear frequency modulation
   inputs. The oscillator has through-zero support, as on negative frequencies the
   phase will move backwards (in clockwise direction).
   The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:base-frequency The frequency emitted by the oscillator when all frequency control 
           voltages are 0.</li>
	<li>:f-max The maximum frequency of the oscillator. f-max must be greater than 0.</li>
	<li>:cv-max The absolute value of the frequency control peak voltage of the :cv-lin input which
           represents the maximum frequency of the oscillator.</li>
	<li>:v-peak Absolute value of the output peak voltage emitted by the oscillator.</li>
	<li>:duty-cycle The duty cycle of the square wave. 0 <= duty-cycle <= 1.</li>
	<li>:phase-offset A phase offset in radians.</li>
    </ul>
    The module has the following inputs:
    <ul>
	<li>:cv-exp Exponential frequency control voltage. For a given base-frequency of 440Hz a
	    control voltage of 1.0 results in a frequency of 880Hz and a control
	    voltage of -1.0 results in a frequency of 220Hz.
	</li>
        <li>:cv-lin Bipolar linear frequency control voltage. Example: If the :f-max of the oscillator
           is 12000Hz and :cv-max is 5.0V then a :cv-lin of 2.5V results in a frequency of 6000Hz and 
           a :cv-lin of -2.5V results in a frequency of -6000Hz.</li>
    </ul>
    The frequency of the oscillator is calculated by adding the frequencies resulting from the
    :cv-lin and :cv-exp inputs. It is clipped according to the :f-max setting.
    The module has the following outputs:
    <ul>
	<li>:sine A sine wave.</li>
	<li>:triangle A triangle wave.</li>
	<li>:saw A saw wave.</li>
	<li>:square A square wave.</li>
    </ul>
    <p>The module exposes the following states via the get-state function:
       <ul>
          <li>:frequency The current frequency of the module.</li>
          <li>:linear-frequency The current linear frequency part of the module.</li>
          <li>:exponential-frequency The current exponential frequency part of the module.</li>
          <li>:phase The current phase in radians (0..2PI).</li>
       </ul>
    </p></p><p><b>Example:</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-vco-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-vco-example-1)

(defun example ()
  "Write all wave forms into a Wave and a Csv file"
  (let ((rack (cl-synthesizer:make-rack :environment (cl-synthesizer:make-environment))))
    (cl-synthesizer:add-module
     rack
     "VCO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 10.0 :v-peak 5.0 :cv-max 5.0 :f-max 12000.0)

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-wave-handler:make-handler
     '(("VCO" :output-socket :sine)
       ("VCO" :output-socket :triangle)
       ("VCO" :output-socket :saw)
       ("VCO" :output-socket :square))
     :filename "cl-synthesizer-examples/vco-example-1.wav")

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-csv-handler:make-handler
     '(("VCO" :output-socket :sine :name "Sine")
       ("VCO" :output-socket :triangle :name "Triangle")
       ("VCO" :output-socket :saw :name "Saw")
       ("VCO" :output-socket :square :name "Square"))
     :filename "cl-synthesizer-examples/vco-example-1.csv"
     :add-header t
     :column-separator ",")
    
    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 1)))

;; (run-example)</code></pre></p><h4 id="vca">VCA</h4><p><b>cl-synthesizer-modules-vca:make-module</b> name environment &key cv-max (initial-gain 0.0) </p><p>Creates a Voltage Controlled Amplifier/Attenuator module. The VCA multiplies an
    incoming signal with a factor of 0..1. The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:cv-max The value of the effective amplification control voltage that represents the maximum
	    amplification of 1.0.</li>
	<li>:initial-gain An offset that is added to the amplification control voltage.</li>
    </ul>
    The module has the following inputs:
    <ul>
	<li>:cv Amplification control voltage.</li>
	<li>:input Input signal to be amplified. The amplitude of this voltage is
	    unknown to the VCA. It can have any value.</li>
	<li>:gain An offset that is added to the amplification control voltage.</li>
    </ul>
    The effective amplification voltage is v = :cv + :gain + :initial-gain, where 0.0 <= v <= :cv-max.
    The module has the following outputs:
    <ul>
	<li>:output-linear Amplified input signal with linear amplification characteristic.</li>
	<li>:output-exponential Amplified input signal with exponential amplification characteristic.</li>
    </ul></p><p><b>Example:</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-vca-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-vca-example-1)

(defun example ()
  "Amplification of a 10kHz sine wave with a bipolar triangular signal."
  (let ((rack (cl-synthesizer:make-rack :environment (cl-synthesizer:make-environment))))

    ;; Set up oscillator modulating the amplification
    (cl-synthesizer:add-module
     rack "LFO-CV"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 0.5
     :v-peak 5.0
     :cv-max 5.0
     :f-max 12000.0)

    ;; set up oscillator providing the audio signal
    (cl-synthesizer:add-module
     rack "VCO-AUDIO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 10000.0
     :v-peak 5.0
     :cv-max 5.0
     :f-max 12000.0)

    ;; Set up VCA
    (cl-synthesizer:add-module
     rack "VCA"
     #'cl-synthesizer-modules-vca:make-module
     :cv-max 5.0)

    ;; Add patches
    (cl-synthesizer:add-patch rack "VCO-AUDIO" :sine "VCA" :input)
    (cl-synthesizer:add-patch rack "LFO-CV" :triangle "VCA" :cv)

    ;; Record VCA inputs/outputs into a Wave-File
    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-wave-handler:make-handler
     '(("VCA" :input-socket :cv)
       ("VCA" :input-socket :input)
       ("VCA" :output-socket :output-linear)
       ("VCA" :output-socket :output-exponential))
     :filename "cl-synthesizer-examples/vca-example-1.wav")
    
    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 120)))

;; (run-example)</code></pre></p><h4 id="adsr">ADSR</h4><p><b>cl-synthesizer-modules-adsr:make-module</b> name environment &key attack-time-ms attack-target-output decay-time-ms decay-target-output release-time-ms (time-cv-to-time-ms nil) (gate-threshold 2.5) (backward-coupled nil) </p><p>Creates an envelope generator module with the phases Attack, Decay, Sustain and Release.
    This module has been realized using other modules such as Ramp, Sustain, Trigger and Multiple.
    The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:attack-time-ms Duration of the attack phase in milliseconds.</li>
	<li>:attack-target-output Target value of the attack phase.</li>
	<li>:decay-time-ms Duration of the decay phase in milliseconds.</li>
	<li>:decay-target-output Target value of the decay phase.</li>
	<li>:release-time-ms Duration of the release phase in milliseconds. The release phase climbs to 0.0.</li>
	<li>:time-cv-to-time-ms Optional function that converts a time control voltage to a duration in milliseconds
	    (see also Ramp module).</li>
	<li>:gate-threshold Minimum value of the :gate input that indicates that the gate is on.</li>
        <li>:backward-coupled If t then the output signal of the envelope will be connected with 
            the input of the attack phase. This can be used to avoid sudden jumps of the envelope 
            as the attack phase by default starts at 0.0.</li>
    </ul>
    The module has the following inputs:
    <ul>
	<li>:gate The gate signal (see also :gate-threshold). The envelope starts working when the
	gate input switches to "on" and enters into the release phase when it switches to "off".</li>
	<li>:attack-cv-time Modulates the climbing time of the attack phase (see also Ramp module).</li>
	<li>:release-cv-time Modulates the climbing time of the release phase (see also Ramp module).</li>
    </ul>
    The module has the following outputs:
    <ul>
	<li>:cv The envelope.</li>
    </ul></p><p><b>Example:</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-adsr-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-adsr-example-1)

(defun example ()
  "ADSR example"
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment))))
    
    (cl-synthesizer:add-module
     rack "MIDI-SEQUENCER"
     #'cl-synthesizer-modules-midi-sequencer:make-module :events
     (list 
      (list :timestamp-milli-seconds 0
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-on-event 1 69 100)))
      (list :timestamp-milli-seconds 1500
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-off-event 1 69 100)))))

    (cl-synthesizer:add-module
     rack "MIDI-IFC"
     #'cl-synthesizer-modules-midi-interface:make-module :voice-count 1)

    (cl-synthesizer:add-module
     rack "ADSR"
     #'cl-synthesizer-modules-adsr:make-module
     :attack-time-ms 500 :attack-target-output 5.0
     :decay-time-ms 250 :decay-target-output 4.0
     :release-time-ms 1000)
    
    (cl-synthesizer:add-patch rack "MIDI-SEQUENCER" :midi-events "MIDI-IFC" :midi-events)
    (cl-synthesizer:add-patch rack "MIDI-IFC" :gate-1 "ADSR" :gate)

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-csv-handler:make-handler
     '(("ADSR" :input-socket :gate :name "ADSR Gate In")
       ("ADSR" :output-socket :cv :name "ADSR Out"))
     :filename "cl-synthesizer-examples/adsr-example-1.csv")
    
    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 3)))

;; (run-example)</code></pre></p><h4 id="multiple">Multiple</h4><p><b>cl-synthesizer-modules-multiple:make-module</b> name environment &key output-count </p><p>Creates a Multiple module. A multiple passes the value of exactly one input socket
   to as many output sockets as defined by output-count.
   The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:output-count The number of output sockets.</li>
    </ul>
    The module has the following inputs:
    <ul>
	<li>:input The input signal to be passed to the outputs.</li>
    </ul>
    The module has the following outputs:
    <ul>
        <li>:output-1 ... :output-n. Where n is the output-count.</li>
    </ul></p><p><b>Example:</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-multiple-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-multiple-example-1)

(defun example ()
  "Multiple example"
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment)
               :output-sockets '(:line-out-1 :line-out-2))))
    
    (cl-synthesizer:add-module
     rack "LFO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 1.0 :v-peak 1.0 :f-max 500.0 :cv-max 5.0)
    
    (cl-synthesizer:add-module rack "MULTIPLE"
                               #'cl-synthesizer-modules-multiple:make-module :output-count 5)
    (cl-synthesizer:add-patch rack "LFO" :sine "MULTIPLE" :input)
    (cl-synthesizer:add-patch rack "MULTIPLE" :output-1 "OUTPUT" :line-out-1)
    (cl-synthesizer:add-patch rack "MULTIPLE" :output-2 "OUTPUT" :line-out-2)

    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 10)))

;; (run-example)</code></pre></p><h4 id="midi-interface">MIDI Interface</h4><p><b>cl-synthesizer-modules-midi-interface:make-module</b> name environment &key (voice-count 1) (channel nil) (note-number-to-cv (lambda (note-number) (the single-float (/ note-number 12.0)))) (play-mode :play-mode-poly) (cv-gate-on 5.0) (cv-gate-off 0.0) (force-gate-retrigger nil) </p><p>Creates a MIDI interface module. The module dispatches MIDI-Note events to so called voices where each
    voice is represented by a control-voltage and a gate signal. The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:voice-count The number of voices to be exposed by the module. Each voice consists
	    of the following output sockets:
	    <ul>
		<li>:gate-n The gate signal. n = 1..voice-count.</li>
		<li>:cv-n A control voltage representing the note number.
		    n = 1..voice-count.</li>
	    </ul>
        </li>
	<li>:channel Optional MIDI channel to which note events (not CC-Events) must belong. By default the
	    channel is ignored.</li>
	<li>:note-number-to-cv An optional function that is called with a MIDI note number
	    and returns a control-voltage.</li>
	<li>:play-mode
	    <ul>
		<li>:play-mode-poly Polyphonic play mode. Incoming note events will be
		    dispatched to "available" voices.</li>
		<li>:play-mode-unisono Monophonic play mode. All voices exposed by the module
		    are set to the current "active" note. Notes are stacked. When a note is
		    released, the voice outputs switch to the previous note.</li>
	    </ul>
            <p>
            The handling of play-modes is implemented by the package 
            cl-synthesizer-midi-voice-manager:voice-manager.
            </p>
        </li>
	<li>:cv-gate-on The "Gate on" control voltage.</li>
	<li>:cv-gate-off The "Gate off" control voltage.</li>
	<li>:force-gate-retrigger If t then in :play-mode-unisono play mode each note
	    event will cause a retriggering of the gate signal. Otherwise the gate signal
	    will just stay on when it is already on.</li>
    </ul>
    Gate transitions are implemented as follows:
    <ul>
	<li>In :play-mode-poly play mode each incoming note causes that the gate signal of the
	    assigned voice switches to On. If the gate signal of the assigned voice is already On
	    (this happens when the available voices are exhausted and a voice is "stolen") then
	    the gate signal switches to Off for the duration of one system tick and
	    then to On again.</li>
	<li>In :play-mode-unisono play mode incoming notes are stacked. The first note causes
	    the gate signal to switch to On. Further "nested" note-on events only result
	    in a change of the CV output but the gate signal will stay On.
	    This behaviour can be overridden with the :force-gate-retrigger parameter.</li>
    </ul>
    The module has the following inputs:
    <ul>
	<li>:midi-events A list of MIDI events.</li>
    </ul>
    The module has the following outputs:
    <ul>
	<li>:gate-1 ... :gate-n</li>
	<li>:cv-1 ... :cv-n</li>
    </ul>
    For an example see <b>midi-sequencer</b></p><hr/><h4 id="midi-cc-interface">MIDI CC Interface</h4><p><b>cl-synthesizer-modules-midi-cc-interface:make-module</b> name environment &key controller-numbers transform-handler (channel nil) (initial-output 0) (min-output nil) (max-output nil) </p><p>Creates a MIDI CC Event interface module. The module maps MIDI control change events to
   an output value. The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:controller-numbers A list of MIDI controller numbers.</li>
        <li>:transform-handler A function that converts a control value to 
            the output value of the module. It is called for each 
            matching CC event and has the following arguments:
            <ul>
                <li>The current output value of the module.</li>
                <li>Controller number.</li>
                <li>Control value.</li>
            </ul>
            <p>The function must return the new output value of the module.</p>
        </li>
        <li>:channel Optional number of the MIDI channel to which the controller events 
          must belong. By default there is no channel filtering applied.</li>
        <li>:initial-output The initial output value of the module.</li>
        <li>:min-output Optional lowest numeric output value of the module. If
        the transform handler returns a number smaller than min-output then
        the actual output-value is set to min-output.</li>
        <li>:max-output Optional largest numeric output value of the module. If
          the transform handler returns a number greater than max-output then
          the actual output value is set to max-output.</li>
    </ul>
    The module has the following inputs:
    <ul>
	<li>:midi-events A list of MIDI events.</li>
    </ul>
    The module has the following outputs:
    <ul>
	<li>:output The current output value.</li>
    </ul></p><p><b>Example:</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-midi-cc-interface-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-midi-cc-interface-example-1)

(defun example ()
  "MIDI CC-Interface Example"
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment)
               :input-sockets '(:midi-events))))

    (cl-synthesizer:add-module
     rack "MIDI-CC-IFC" #'cl-synthesizer-modules-midi-cc-interface:make-module
     :controller-numbers '(112)
     :initial-output 2.5
     :min-output 0.0
     :max-output 5.0
     :transform-handler
     (lambda (cur-output controller-number control-value)
       (declare (ignore controller-number))
       (cond
         ((= control-value 61)
          (+ cur-output -0.5))
         ((= control-value 67)
          (+ cur-output 0.5))
         (t cur-output)))
     :channel nil)
    
    (cl-synthesizer:add-patch rack "INPUT" :midi-events "MIDI-CC-IFC" :midi-events)

    rack))

(defun run-example ()
  (cl-synthesizer::play-rack (example) :duration-seconds 5))

;; (run-example)</code></pre></p><h4 id="midi-sequencer">MIDI Sequencer</h4><p><b>cl-synthesizer-modules-midi-sequencer:make-module</b> name environment &key events </p><p>Creates a Midi-Sequencer module.
	The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:events A list of Midi events and their timestamps. Each
	    entry consists of a property list with the following keys:
	    <ul>
		<li>:timestamp-milli-seconds Point of time when events are to be fired. The very first
                timestamp of the synthesizer is 0.</li>
		<li>:midi-events List of Midi events to be fired.</li>
	    </ul>
            The events must be ordered by timestamp and there must be no duplicate timestamps. 
	</li>
    </ul>
    The module has no inputs.
    The module has one output socket :midi-events.</p><p><b>Example:</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-midi-sequencer-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-midi-sequencer-example-1)

(defun example ()
  "Midi-Sequencer example"
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment)
               :output-sockets '(:line-out))))

    ;; Add sequencer
    (cl-synthesizer:add-module
     rack
     "MIDI-SEQUENCER"
     #'cl-synthesizer-modules-midi-sequencer:make-module :events
     (list 
      (list :timestamp-milli-seconds 0
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-on-event 1 69 100)))
      (list :timestamp-milli-seconds 1000
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-off-event 1 69 100)))
      (list :timestamp-milli-seconds 2000
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-on-event 1 75 100)))
      (list :timestamp-milli-seconds 2500
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-off-event 1 75 100)))))

    ;; Add MIDI Interface and connect it with the MIDI Sequencer
    (cl-synthesizer:add-module
     rack
     "MIDI-IFC"
     #'cl-synthesizer-modules-midi-interface:make-module :voice-count 1)
    (cl-synthesizer:add-patch rack "MIDI-SEQUENCER" :midi-events "MIDI-IFC" :midi-events)

    ;; Add VCO
    (cl-synthesizer:add-module
     rack "VCO" #'cl-synthesizer-modules-vco:make-module
     :base-frequency (cl-synthesizer-midi:get-note-number-frequency 0)
     :f-max 12000.0
     :cv-max 5.0
     :v-peak 5.0)

    ;; Add ADSR
    (cl-synthesizer:add-module
     rack "ADSR"
     #'cl-synthesizer-modules-adsr:make-module
     :attack-time-ms 100 :attack-target-output 5.0
     :decay-time-ms 50 :decay-target-output 3.0
     :release-time-ms 100)
    
    ;; Add VCA
    (cl-synthesizer:add-module rack "VCA" #'cl-synthesizer-modules-vca:make-module :cv-max 5.0)

    ;; Connect VCA with ADSR and VCO
    (cl-synthesizer:add-patch rack "VCA" :output-linear "OUTPUT" :line-out)
    (cl-synthesizer:add-patch rack "ADSR" :cv "VCA" :cv)
    (cl-synthesizer:add-patch rack "VCO" :triangle "VCA" :input)
    
    ;; Connect Midi interface with ADSR and VCO
    (cl-synthesizer:add-patch rack "MIDI-IFC" :cv-1 "VCO" :cv-exp)
    (cl-synthesizer:add-patch rack "MIDI-IFC" :gate-1 "ADSR" :gate)

    ;; Record LINE-OUT into a wave file
    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-wave-handler:make-handler
     '(("OUTPUT" :input-socket :line-out))
     :filename "cl-synthesizer-examples/midi-sequencer-example-1.wav")
    
    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer::play-rack rack :duration-seconds 5)))

;; (run-example)</code></pre></p><h4 id="fixed-output">Fixed Output</h4><p><b>cl-synthesizer-modules-fixed-output:make-module</b> name environment &key value (output-socket :out) </p><p>Creates a module with a fixed output value.
   The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:value The value of the module output.</li>
	<li>:output-socket Optional keyword that declares the output socket
	    identifier to be exposed by the module.</li>
    </ul>
    The module has no inputs.
    The module has one output socket according to the :output-socket argument.</p><p><b>Example:</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-fixed-output-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-fixed-output-example-1)

(defun example ()
  "Fixed-Output example"
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment)
               :output-sockets '(:line-out))))
    
    (cl-synthesizer:add-module
     rack "FIXED-OUTPUT"
     #'cl-synthesizer-modules-fixed-output:make-module
     :value 3.0
     :output-socket :fixed)
    
    (cl-synthesizer:add-patch rack "FIXED-OUTPUT" :fixed "OUTPUT" :line-out)

    rack))

(defun run-example ()
  (cl-synthesizer:play-rack (example) :duration-seconds 1))

;; (run-example)</code></pre></p><h4 id="adder">Adder</h4><p><b>cl-synthesizer-modules-adder:make-module</b> name environment &key input-count </p><p>Creates a simple voltage adder module. The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:input-count The number of input sockets.</li>
    </ul>
    The module has the following inputs:
    <ul>
        <li>:input-1 ... :input-n. Where n is the input-count. Input values
        not of type <b>number</b> are ignored.</li>
    </ul>
    The module has the following outputs:
    <ul>
	<li>:output The output consisting of the sum of the inputs.</li>
    </ul></p><h4 id="mixer">Mixer</h4><p><b>cl-synthesizer-modules-mixer:make-module</b> name environment &key channel-count (channel-cv-max 5.0) (channel-cv-gain 5.0) (main-cv-max 5.0) (main-cv-gain 5.0) </p><p>Creates a mixer module. The mixer provides an attenuator for each input and a main
   attenuator for the mixer output. All attenuators have linear amplification
   characteristic. The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:channel-count The number of channels.</li>
        <li>:channel-cv-max The value of a channel attenuation control voltage that 
        represents an amplification of 1.0.</li>
        <li>:channel-cv-gain An offset that is added to the channel attenuation 
        control voltage.</li>
        <li>:main-cv-max The value of the main attenuation input that 
        represents an amplification of 1.0.</li>
        <li>:main-cv-gain An offset that is added to the main attenuation 
        control voltage.</li>
    </ul>
    The module has the following inputs:
    <ul>
        <li>:channel-1 ... :channel-n. Channel input signal, where n is the channel-count.</li>
        <li>:cv-1 ... :cv-n. Channel attenuation control voltage, where n is the channel-count.</li>
        <li>:cv-main Attenuation control voltage of the mixer output.</li> 
    </ul>
    The module has the following outputs:
    <ul>
	<li>:output The output consisting of the sum of the inputs.</li>
    </ul></p><p><b>Example:</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-mixer-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-mixer-example-1)

(defun example ()
  "Mixer example."
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment)
               :output-sockets '(:line-out))))

    ;;
    ;; add modules...
    ;;
    
    (cl-synthesizer:add-module
     rack "MIXER" #'cl-synthesizer-modules-mixer:make-module
     :channel-count 2
     :channel-cv-max 5.0
     :channel-cv-gain 5.0
     :main-cv-max 5.0
     :main-cv-gain 2.5)
    
    (cl-synthesizer:add-patch rack "VOICE-1" :audio "MIXER" :channel-1)
    (cl-synthesizer:add-patch rack "VOICE-2" :audio "MIXER" :channel-2)
    (cl-synthesizer:add-patch rack "MIXER" :output "OUTPUT" :line-out)
    
    rack))</code></pre></p><h4 id="trigger">Trigger</h4><p><b>cl-synthesizer-modules-trigger:make-module</b> name environment &key trigger-threshold pulse-voltage </p><p>Creates a Voltage to Trigger Converter module. 
   The module fires a one clock cycle long pulse when input voltage >= trigger-threshold
   and then waits that the input voltage descends below trigger-threshold before the next
   pulse can be triggered. The module can for example be used to generate a trigger
   out of a gate signal. The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:trigger-threshold The minimum value of the input which triggers a pulse.</li>
	<li>:pulse-voltage The voltage of the pulse.</li>
    </ul>
    The module has the following inputs:
    <ul>
	<li>:input The input voltage.</li>
    </ul>
    The module has the following outputs:
    <ul>
        <li>:output The output voltage (zero or pulse-voltage).</li>
    </ul></p><p><b>Example:</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-trigger-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-trigger-example-1)

(defun example ()
  "Emit trigger signal based on sine input"
  (let ((rack (cl-synthesizer:make-rack :environment (cl-synthesizer:make-environment))))
    (cl-synthesizer:add-module
     rack
     "VCO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 5.0 :v-peak 5.0 :cv-max 5.0 :f-max 12000.0)

    (cl-synthesizer:add-module
     rack
     "TRIGGER"
     #'cl-synthesizer-modules-trigger:make-module
     :trigger-threshold 4.9 :pulse-voltage 3.0)

    (cl-synthesizer:add-patch rack "VCO" :sine "TRIGGER" :input)
    
    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-wave-handler:make-handler
     '(("TRIGGER" :input-socket :input)
       ("TRIGGER" :output-socket :output))
     :filename "cl-synthesizer-examples/trigger-example-1.wav")

    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 2)))

;; (run-example)</code></pre></p><h4 id="ramp">Ramp</h4><p><b>cl-synthesizer-modules-ramp:make-module</b> name environment &key time-ms target-output (gate-state nil) (trigger-threshold 2.5) (gate-threshold 2.5) (time-cv-to-time-ms nil) </p><p>Creates a module whose output climbs from a given input value to a given output value
    in a given time. Main purpose of this module is to create envelope generators by chaining
    multiple ramp and sustain modules. The module climbs linearly (exponential climbing will
    be added later). The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:time-ms Default climbing time (duration) in milliseconds.</li>
	<li>:target-output Desired target output value. Due to the time resolution given by the sample-rate 
	    of the environment the ramp may stop at an output value a little bit smaller or 
	    greater than the desired target-output value.</li>
	<li>:gate-state Required state of the Gate input. One of :on, :off, nil</li>
	<li>:trigger-threshold Minimum value of the :trigger input that indicates that the trigger is active.</li>
	<li>:gate-threshold Minimum value of the :gate input that indicates that the gate is on.</li>
	<li>:time-cv-to-time-ms An optional function that converts a time control voltage to a duration in milliseconds.
        The default implementation is 1000ms/1V (abs(cv-time) * 1000).</li>
    </ul>
    The module has the following inputs:
    <ul>
	<li>:trigger Trigger input. If the trigger is active (see also :trigger-threshold), the module samples
	    its current input value and begins climbing to the desired target output value.</li>
	<li>:input Input value.</li>
	<li>:pass-through If value is >= 5.0 the module passes through its input value.</li>
	<li>:gate A gate signal (see also :gate-threshold).</li>
	<li>:cv-time NIL or climbing time (duration) of the ramp (see also :time-cv-to-time-ms).</li>
    </ul>
    The module has the following outputs:
    <ul>
	<li>:output Output value of the module. The initial output value is 0.0.</li>
	<li>:busy A value >= 5.0 indicates that the module is busy by either passing through
	its input value or climbing to the target output value.</li>
	<li>:done A trigger signal that jumps to 5.0 for the length of one clock cycle when the ramp has
	finished.</li>
	<li>:gate Passed through :gate input. Purpose of this output is to support more convenient
	    chaining of ramp and sustain modules.</li>
    </ul>
    When the ramp aborts due to a toggling Gate signal or when its supposed
    duration has been exceeded due to time modulation then the output value does not jump 
    to the desired target-output but stays at its current value.<br><br>
    This module has been inspired by <a href="https://github.com/dhemery/DHE-Modules/wiki/Multi-Stage-Envelopes">dhemery</a></p><p><b>Example:</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-ramp-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-ramp-example-1)

(defun example ()
  "Ramp example"
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment))))
    
    (cl-synthesizer:add-module
     rack "VCO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 0.5 :v-peak 5.0 :f-max 500.0 :cv-max 5.0)

    (cl-synthesizer:add-module
     rack "TRIGGER"
     #'cl-synthesizer-modules-trigger:make-module
     :trigger-threshold 4.9 :pulse-voltage 5.0)

    (cl-synthesizer:add-module
     rack "ATTACK"
     #'cl-synthesizer-modules-ramp:make-module
     :time-ms 200 :target-output 5.0 :gate-state nil)

    (cl-synthesizer:add-module
     rack "DECAY"
     #'cl-synthesizer-modules-ramp:make-module
     :time-ms 200 :target-output 2.5)
    
    (cl-synthesizer:add-patch rack "VCO" :square "TRIGGER" :input)
    (cl-synthesizer:add-patch rack "TRIGGER" :output "ATTACK" :trigger)
    (cl-synthesizer:add-patch rack "ATTACK" :busy "DECAY" :pass-through)
    (cl-synthesizer:add-patch rack "ATTACK" :output "DECAY" :input)
    (cl-synthesizer:add-patch rack "ATTACK" :done "DECAY" :trigger)

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-csv-handler:make-handler
     '(("VCO" :output-socket :square :name "VCO Out")
       ("ATTACK" :output-socket :output :name "Attack Out")
       ("DECAY" :output-socket :output :name "Decay Out"))
     :filename "cl-synthesizer-examples/ramp-example-1.csv")
    
    rack))

(defun run-example ()
  (let ((rack (example))) (cl-synthesizer:play-rack rack :duration-seconds 5)))

;; (run-example)</code></pre></p><h4 id="sustain">Sustain</h4><p><b>cl-synthesizer-modules-sustain:make-module</b> name environment &key (trigger-threshold 2.5) (gate-threshold 2.5) </p><p>Creates a module which holds a given input as long as its gate input is "on".
    Main purpose of this module is to create envelope generators by chaining
    multiple ramp and sustain modules. The function has the following arguments:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:trigger-threshold Minimum value of the :trigger input that indicates that the trigger is active.</li>
	<li>:gate-threshold Minimum value of the :gate input that indicates that the gate is on.</li>
    </ul>
    The module has the following inputs:
    <ul>
	<li>:trigger Trigger input. If the trigger is active (see also :trigger-threshold), the module samples
	    its current input value and begins passing it to its output socket.</li>
	<li>:input Input value.</li>
	<li>:pass-through If value is >= 5.0 the module passes through its input value.</li>
	<li>:gate A gate signal (see also :gate-threshold).</li>
    </ul>
    The module has the following outputs:
    <ul>
	<li>:output Output value of the module. The initial output value is 0.0.</li>
	<li>:busy A value >= 5.0 indicates that the module is busy by either passing through
	    its input value or holding the sampled input value until the gate input falls to zero.</li>
	<li>:done A trigger signal that jumps to 5.0 for the length of one clock cycle when the sustain cycle
	    has finished.</li>
	<li>:gate Passed through :gate input. Purpose of this output is to support more convenient
	    chaining of ramp and sustain modules.</li>
    </ul>
    This module has been inspired by <a href="https://github.com/dhemery/DHE-Modules/wiki/Multi-Stage-Envelopes">dhemery</a></p><p><b>Example:</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-sustain-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-sustain-example-1)

(defun example ()
  "Sustain example"
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment))))
    
    ;; Use MIDI sequencer for generation of Gate signals
    (cl-synthesizer:add-module
     rack "MIDI-SEQUENCER"
     #'cl-synthesizer-modules-midi-sequencer:make-module :events
     (list 
      (list :timestamp-milli-seconds 300
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-on-event 1 69 100)))
      (list :timestamp-milli-seconds 700
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-off-event 1 69 100)))
      (list :timestamp-milli-seconds 1800
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-on-event 1 69 100)))
      (list :timestamp-milli-seconds 2100
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-off-event 1 69 100)))))

    (cl-synthesizer:add-module
     rack "MIDI-IFC"
     #'cl-synthesizer-modules-midi-interface:make-module :voice-count 1)

    (cl-synthesizer:add-module
     rack "GATE-MULTIPLE"
     #'cl-synthesizer-modules-multiple:make-module :output-count 2)

    (cl-synthesizer:add-module
     rack "TRIGGER"
     #'cl-synthesizer-modules-trigger:make-module
     :trigger-threshold 4.9 :pulse-voltage 5.0)

    (cl-synthesizer:add-module
     rack "VCO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 0.5 :v-peak 5.0 :cv-max 5.0 :f-max 12000.0)
    
    (cl-synthesizer:add-module
     rack "SUSTAIN"
     #'cl-synthesizer-modules-sustain:make-module)

    (cl-synthesizer:add-patch rack "MIDI-SEQUENCER" :midi-events "MIDI-IFC" :midi-events)
    (cl-synthesizer:add-patch rack "MIDI-IFC" :gate-1 "GATE-MULTIPLE" :input)
    (cl-synthesizer:add-patch rack "GATE-MULTIPLE" :output-1 "TRIGGER" :input)
    (cl-synthesizer:add-patch rack "GATE-MULTIPLE" :output-2 "SUSTAIN" :gate)
    (cl-synthesizer:add-patch rack "TRIGGER" :output "SUSTAIN" :trigger)
    (cl-synthesizer:add-patch rack "VCO" :sine "SUSTAIN" :input)

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-csv-handler:make-handler
     '(("MIDI-IFC" :output-socket :gate-1 :name "Gate")
       ("SUSTAIN" :input-socket :trigger :name "Sustain Trigger In")
       ("SUSTAIN" :input-socket :input :name "Sustain In")
       ("SUSTAIN" :output-socket :output :name "Sustain Out")
       ("SUSTAIN" :output-socket :done :name "Sustain Done Out"))
     :filename "cl-synthesizer-examples/sustain-example-1.csv")
    
    rack))

(defun run-example ()
  (let ((rack (example))) (cl-synthesizer:play-rack rack :duration-seconds 3)))

;; (run-example)</code></pre></p><h4 id="wave-file-writer">Wave File Writer</h4><p><b>cl-synthesizer-modules-wave-file-writer:make-module</b> name environment &key channel-count filename (v-peak 5.0) (sample-width :16bit) </p><p>Creates a Wave File Writer module. Writes files in "Waveform Audio File" ("WAV") format.
    The function has the following arguments:
  <ul>
    <li>name Name of the writer.</li>
    <li>environment The synthesizer environment.</li>
    <li>:channel-count Number of channels.</li>
    <li>:filename The relative path of the file to be written. The filename will be concatenated
        with the base path as defined by the :home-directory property of the environment.</li>
    <li>:v-peak Optional peak voltage. The inputs of the module will be scaled
	to v-peak. If for example v-peak is set to 20.0 an incoming voltage
	of 5.0 results in a sample value (which is written into the wave file)  
        of 5.0 / 20.0 -> 0.25 and an incoming voltage of -5.0 results in a sample 
        value of -0.25. The default value is 5.0. Incoming voltages will be clipped 
        according to v-peak.</li>
    <li>:sample-width Resolution of samples. One of :8Bit, :16Bit, :24Bit</li> 
  </ul>
  The module has the following inputs:
  <ul>
      <li>:channel-1 ... :channel-n The sample values of the generated frames
	  are written in order :channel-1 ... :channel-n</li>
  </ul>
  The module has no outputs.
  <p>See also cl-synthesizer-monitor:add-monitor which provides Wave-File-Writing
     without having to add the module and the required patches to the rack.</p></p><h4 id="csv-file-writer">CSV File Writer</h4><p><b>cl-synthesizer-modules-csv-file-writer:make-module</b> name environment &key columns filename (column-separator ",") (add-header t) </p><p>Creates a CSV File Writer module.
    The function has the following arguments:
  <ul>
    <li>name Name of the writer.</li>
    <li>environment The synthesizer environment.</li>
    <li>:columns A list of column definitions. Each colum definition consists of a property list 
        with the following keys:
        <ul>
            <li>:name Name of the column.</li>
            <li>:default-value Default value to be used if current column value is nil.</li>
        </ul>
    </li>
    <li>:filename The relative path of the file to be written. The filename will be concatenated
        with the base path as defined by the :home-directory property of the environment.</li>
    <li>:column-separator The column separator.</li>
    <li>:add-header If t then a header consisting of the column-names will be written.</li>
  </ul>
  The module has the following inputs:
  <ul>
      <li>:column-1 ... :column-n Where n is the number of columns.</li>
  </ul>
  <p>Due to performance/consing considerations all columns are written using the Lisp-Writer. 
     If a value contains the column separator it will not be quoted. The file is opened on the first 
     call of the update function and closed by the shutdown handler.
  </p>
  The module has no outputs.
  <p>See also cl-synthesizer-monitor:add-monitor</p></p></section><section class="container"><h3 id="monitor">Monitor</h3><p><b>cl-synthesizer-monitor:add-monitor</b> rack monitor-handler socket-mappings &rest additional-handler-args </p><p>Adds a monitor to a rack. A monitor is a high-level Rack hook that
    collects module states (values of input/output/state sockets) and 
    passes them to a monitor handler. A monitor handler can for example be a
    Wave-File-Writer. The function has the following arguments:
    <ul>
	<li>rack The rack.</li>
	<li>monitor-handler A function that instantiates the monitor handler.
	    This function is called with the following arguments:
	    <ul>
		<li>name A name.</li>
		<li>environment The synthesizer environment.</li>
		<li>inputs A list of inputs. Each entry consists of the additional
                    settings that have been set at a specific socket mapping, for example
                    the CSV formatting string.</li>
		<li>additional-handler-args Any additional keyword parameters as
		    passed to the monitor function. These parameters can be
		    used to initialize handler specific properties such as
		    a filename.</li>
	    </ul>
	    The function must return a values object with the following entries:
	    <ul>
		<li>module A property list that implements a module. See also cl-synthesizer:add-module.</li>
		<li>An ordered list of input sockets of the module, where the first entry represents 
                   the first entry of the socket mappings (e.g. column-1) and so on. This list
                   is in place because we cannot depend on the order of the input sockets
                   exposed by the module. It is up to the monitor-handler to know about 
                   specifica of modules, for example that the csv-file-writer module
                   uses input socket :column-1 to represent the first column.</li>
	    </ul>
	</li>
	<li>socket-mappings Declares the input/outputs/states whose values are to be monitored.
            Each entry has the following format:
	    <ul>
		<li>module-path Path of the module from which the value of
		    a certain input/output socket or state is to be retrieved, for
		    example "ADSR" or '("VOICE-1" "ADSR"). 
                    See also cl-synthesizer:find-module.</li>
		<li>socket-type One of the following keywords: 
                    <ul>
                        <li>:input-socket The value of an input socket of the module.</li>
                        <li>:output-socket The value of an output socket of the module.</li>
                        <li>:state The value of an internal state of the module (see get-state function).</li>
                    </ul>
                </li>
		<li>socket A keyword that identifies one of the input/output sockets or internal states
		    provided by the module, for example :cv</li>
                <li>Any additional settings. Supported settings depend
                    on the handler that is being used, for example a CSV writer may
                    support a column formatting string.</li>
	    </ul>
	</li>
	<li>&rest additional-handler-args Optional keyword arguments to be passed to
	    the handler instantiation function.</li>
    </ul></p><p><b>Example:</b></p><p><pre><code>(defpackage :cl-synthesizer-monitor-example-1
  (:use :cl))

(in-package :cl-synthesizer-monitor-example-1)

(defun example ()
  "Monitor example"
  (let ((rack (cl-synthesizer:make-rack :environment (cl-synthesizer:make-environment))))
    
    (cl-synthesizer:add-module
     rack
     "VCO"
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 10.0 :v-peak 5.0 :cv-max 5.0 :f-max 12000.0)

    (flet ((instantiate-handler (name environment inputs)
             (declare (ignore name environment inputs))
             (let ((input-sine nil) (input-phase nil))
               (values 
                (list
                 :inputs (lambda()
                           (list
                            :sine (lambda(value) (setf input-sine value))
                            :phase (lambda(value) (setf input-phase value))))
                 :outputs (lambda()
                            (list
                             :sine (lambda() input-sine)
                             :phase (lambda() input-phase)))
                 :update (lambda () nil))
                '(:sine :phase)))))
      
      (cl-synthesizer-monitor:add-monitor
       rack
       #'instantiate-handler
       '(("VCO" :output-socket :sine)
         ("VCO" :state :phase))))
    
    rack))

(defun run-example ()
  (let ((rack (example)))
    (funcall (getf rack :update))
    (funcall (getf rack :update))))

;; (run-example)</code></pre></p><p><b>cl-synthesizer-monitor-wave-handler:make-handler</b> name environment inputs &rest rest &key filename &allow-other-keys </p><p>Creates a monitor handler which writes its inputs into a Wave file.
    The function has the following arguments:
    <ul>
	<li>name A name.</li>
	<li>environment The synthesizer environment.</li>
	<li>inputs The column input settings as provided by the Monitor component.</li>
	<li>:filename A file path relative to the output directory as defined by the environment.</li>
    </ul>
    <p>See also cl-synthesizer-modules:wave-file-writer.</p></p><hr/><p><b>cl-synthesizer-monitor-csv-handler:make-handler</b> name environment inputs &rest rest &key filename &allow-other-keys </p><p>Creates a monitor handler which writes its inputs into a CSV file.
    The function has the following arguments:
    <ul>
	<li>name A name.</li>
	<li>environment The synthesizer environment.</li>
	<li>inputs The column input settings as provided by the Monitor component.</li>
	<li>:filename A file path relative to the output directory as defined by the environment.</li>
    </ul>
    <p>See also cl-synthesizer-modules:csv-file-writer.</p></p></section><section class="container"><h3 id="midi">MIDI</h3><h4 id="midi-event">MIDI Event</h4><p><b>cl-synthesizer-midi-event:make-control-change-event</b> channel controller-number value </p><p>Creates a MIDI control change event.</p><hr/><p><b>cl-synthesizer-midi-event:make-note-on-event</b> channel note-number velocity </p><p>Creates a MIDI Note-On event.</p><hr/><p><b>cl-synthesizer-midi-event:make-note-off-event</b> channel note-number velocity </p><p>Creates a MIDI Note-Off event.</p><hr/><p><b>cl-synthesizer-midi-event:control-change-eventp</b> event </p><p>Returns t if the given MIDI event is a Control-Change event.</p><hr/><p><b>cl-synthesizer-midi-event:note-on-eventp</b> event </p><p>Returns t if the given MIDI event is a Note-On event.</p><hr/><p><b>cl-synthesizer-midi-event:note-off-eventp</b> event </p><p>Returns t if the given MIDI event is a Note-Off event.</p><hr/><p><b>cl-synthesizer-midi-event:get-channel</b> event </p><p>Returns the MIDI channel number to which the event belongs.</p><hr/><p><b>cl-synthesizer-midi-event:get-controller-number</b> event </p><p>Returns the controller number of a Control-Change MIDI event.</p><hr/><p><b>cl-synthesizer-midi-event:get-controller-value</b> event </p><p>Returns the controller value of a Control-Change MIDI event.</p><hr/><p><b>cl-synthesizer-midi-event:get-note-number</b> event </p><p>Returns the note number of Note-On/Off MIDI event.</p><hr/><p><b>cl-synthesizer-midi-event:get-velocity</b> event </p><p>Returns the velocity of a Note-On/Off MIDI event.</p><h4 id="midi-utilities">MIDI Utilities</h4><p><b>cl-synthesizer-midi:get-note-number-frequency</b> note-number </p><p>Returns the frequency of a given note number. Note number 69 results in a frequency of 440Hz.
   This function implements a mapping according to 
   <a href="http://subsynth.sourceforge.net/midinote2freq.html">midinote2freq</a></p></section><section class="container"><h3 id="conditions">Conditions</h3><b>assembly-error</b><p>This condition is signalled in cases where the assembly of a rack fails,
   because for example a module name is not unique, a patch is added for
   a non-existing module, a patch is added to an already patched socket
   and so on.</p></section><section class="container"><h2>Acknowledgements</h2>
<ul>
<li>Envelope generation has been inspired by <a href="https://github.com/dhemery/DHE-Modules/wiki/Multi-Stage-Envelopes">dhemery</a></li>
</ul></section><footer class="container"><hr/><p><small>Generated 2019-06-27  23:10:18</small></p></footer></body></html>