<html><head><link href="styles.css" rel="stylesheet" type="text/css"/></head><body>
<header>
<h1>cl-synthesizer</h1><p>A Modular Audio Synthesizer Engine implemented in Common Lisp.
    <p>cl-synthesizer is an easy to use library which follows the approach of
      a classical hardware modular synthesizer, where modules are put into a rack and patched together with cables.</p>
<p>The source code of cl-synthesizer can be found <a href="https://github.com/Frechmatz/cl-synthesizer">here</a>.</p></header>
<nav>
<h1>Table of contents</h1>
<ul>
<li><a href="#Installation">Installation</a></li>
<li><a href="#Examples">Examples</a><ul>
<li><a href="#Saw">Saw</a></li>
<li><a href="#Frequency modulated Saw">Frequency modulated Saw</a></li>
<li><a href="#Two frequency modulated Saws">Two frequency modulated Saws</a></li></ul></li>
<li><a href="#Concepts">Concepts</a><ul>
<li><a href="#Environment">Environment</a></li>
<li><a href="#Module">Module</a><ul>
<li><a href="#Example: A module">Example: A module</a></li>
<li><a href="#Example: A module based on other modules">Example: A module based on other modules</a></li></ul></li>
<li><a href="#Rack">Rack</a><ul>
<li><a href="#Example">Example</a></li></ul></li></ul></li>
<li><a href="#API">API</a><ul>
<li><a href="#Environment-1">Environment</a><ul>
<li><a href="#make-environment">make-environment</a></li>
<li><a href="#*home-directory*">*home-directory*</a></li></ul></li>
<li><a href="#Module-1">Module</a><ul>
<li><a href="#get-module-name">get-module-name</a></li>
<li><a href="#get-module-rack">get-module-rack</a></li>
<li><a href="#update">update</a></li>
<li><a href="#shutdown">shutdown</a></li>
<li><a href="#is-rack">is-rack</a></li></ul></li>
<li><a href="#Rack-1">Rack</a><ul>
<li><a href="#make-rack">make-rack</a></li>
<li><a href="#get-environment">get-environment</a></li>
<li><a href="#add-module">add-module</a></li>
<li><a href="#get-module">get-module</a></li>
<li><a href="#get-modules">get-modules</a></li>
<li><a href="#add-patch">add-patch</a></li>
<li><a href="#get-patches">get-patches</a></li>
<li><a href="#add-rack-input">add-rack-input</a></li>
<li><a href="#add-rack-output">add-rack-output</a></li>
<li><a href="#add-hook">add-hook</a></li>
<li><a href="#play-rack">play-rack</a></li></ul></li>
<li><a href="#Modules">Modules</a><ul>
<li><a href="#System">System</a></li>
<li><a href="#VCO">VCO</a></li>
<li><a href="#VCA">VCA</a></li>
<li><a href="#ADSR">ADSR</a></li>
<li><a href="#Multiple">Multiple</a></li>
<li><a href="#Fixed Output">Fixed Output</a></li>
<li><a href="#Adder">Adder</a></li>
<li><a href="#Mixer">Mixer</a></li>
<li><a href="#Trigger">Trigger</a></li>
<li><a href="#Ramp">Ramp</a></li>
<li><a href="#Sustain">Sustain</a></li>
<li><a href="#Wave File Writer">Wave File Writer</a></li>
<li><a href="#CSV File Writer">CSV File Writer</a></li></ul></li>
<li><a href="#Monitors">Monitors</a><ul>
<li><a href="#add-monitor">add-monitor</a></li>
<li><a href="#wave-file-agent">wave-file-agent</a></li>
<li><a href="#csv-file-agent">csv-file-agent</a></li>
<li><a href="#buffer-agent">buffer-agent</a></li></ul></li>
<li><a href="#MIDI">MIDI</a><ul>
<li><a href="#MIDI Event">MIDI Event</a></li>
<li><a href="#MIDI Polyphonic Interface">MIDI Polyphonic Interface</a></li>
<li><a href="#MIDI Monophonic Interface">MIDI Monophonic Interface</a></li>
<li><a href="#MIDI Relative CC Interface">MIDI Relative CC Interface</a></li>
<li><a href="#MIDI Sequencer">MIDI Sequencer</a></li>
<li><a href="#MIDI Utilities">MIDI Utilities</a></li></ul></li>
<li><a href="#Conditions">Conditions</a></li></ul></li>
<li><a href="#Run tests">Run tests</a></li>
<li><a href="#Run examples">Run examples</a></li>
<li><a href="#Run profiler">Run profiler</a></li>
<li><a href="#Generate documentation">Generate documentation</a></li>
<li><a href="#Acknowledgements">Acknowledgements</a></li></ul></nav>
<section>
<h1 id="Installation">Installation</h1><pre><code>cd ~/quicklisp/local-projects
git clone https://github.com/Frechmatz/cl-wave-file-writer.git
git clone https://github.com/Frechmatz/cl-java-sound-client.git    
git clone https://github.com/Frechmatz/cl-synthesizer.git
(ql:quickload "cl-synthesizer")</code></pre>
<h1 id="Examples">Examples</h1>
<h2 id="Saw">Saw</h2><p><pre><code>(defpackage :cl-synthesizer-patches-saw
  (:documentation &quot;Saw&quot;)
  (:use :cl))
(in-package :cl-synthesizer-patches-saw)

(defun example ()
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment))))
    (cl-synthesizer:add-module
     rack
     &quot;VCO&quot;
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 440.0 :v-peak 5.0)
    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-wave-file-agent:make-backend
     '((&quot;VCO&quot; :output-socket :saw))
     :filename &quot;docs/saw.wav&quot;
     :v-peak 5.0)
    rack))

(defun run-example ()
  (cl-synthesizer:play-rack (example) :duration-seconds 3.0))

;; (run-example)</code></pre></p><p><audio controls preload="none">Your browser does not support the <code>audio</code> element.<source src="saw.wav?cb=3952785457" type="audio/wav"></audio></p>
<h2 id="Frequency modulated Saw">Frequency modulated Saw</h2><p><pre><code>(defpackage :cl-synthesizer-patches-frequency-modulated-saw
  (:use :cl)
  (:documentation &quot;Frequency modulated Saw&quot;))
(in-package :cl-synthesizer-patches-frequency-modulated-saw)

(defun example ()
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment))))
    (cl-synthesizer:add-module
     rack
     &quot;LFO&quot;
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 1.0
     :v-peak 5.0)
    (cl-synthesizer:add-module
     rack
     &quot;VCO&quot;
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 440
     :v-peak 5.0
     :cv-lin-hz-v 20.0)
    (cl-synthesizer:add-patch rack &quot;LFO&quot; :sine &quot;VCO&quot; :cv-lin)
    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-wave-file-agent:make-backend
     '((&quot;VCO&quot; :output-socket :saw))
     :filename &quot;docs/frequency-modulated-saw.wav&quot;
     :v-peak 5.0)
    rack))

(defun run-example ()
  (cl-synthesizer:play-rack (example) :duration-seconds 3.0))

;;(run-example)</code></pre></p><p><audio controls preload="none">Your browser does not support the <code>audio</code> element.<source src="frequency-modulated-saw.wav?cb=3952785457" type="audio/wav"></audio></p>
<h2 id="Two frequency modulated Saws">Two frequency modulated Saws</h2><p><pre><code>(defpackage :cl-synthesizer-patches-two-frequency-modulated-saws
  (:use :cl)
  (:documentation &quot;Two frequency modulated Saws&quot;))
(in-package :cl-synthesizer-patches-two-frequency-modulated-saws)

(defun make-modulated-saw (name environment &amp;key lfo-frequency vco-frequency)
  (declare (ignore name))
  (let ((rack (cl-synthesizer:make-rack :environment environment)))
    (cl-synthesizer:add-module
     rack
     &quot;LFO&quot;
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency lfo-frequency :v-peak 5.0)
    (cl-synthesizer:add-module
     rack
     &quot;VCO&quot;
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency vco-frequency :v-peak 5.0 :cv-lin-hz-v 20.0)
    (cl-synthesizer:add-patch rack &quot;LFO&quot; :sine &quot;VCO&quot; :cv-lin)
    (cl-synthesizer:add-rack-output rack :saw &quot;VCO&quot; :saw)
    rack))

(defun example ()
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment))))
    (cl-synthesizer:add-module
     rack &quot;SAW-1&quot; #'make-modulated-saw :lfo-frequency 1.0 :vco-frequency 440.0)
    (cl-synthesizer:add-module
     rack &quot;SAW-2&quot; #'make-modulated-saw :lfo-frequency 2.0 :vco-frequency 442.0)
    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-wave-file-agent:make-backend
     '((&quot;SAW-1&quot; :output-socket :saw)
       (&quot;SAW-2&quot; :output-socket :saw))
     :filename &quot;docs/two-frequency-modulated-saws.wav&quot;
     :v-peak 5.0)
    rack))

(defun run-example ()
  (cl-synthesizer:play-rack (example) :duration-seconds 3.0))

;;(run-example)</code></pre></p><p><audio controls preload="none">Your browser does not support the <code>audio</code> element.<source src="two-frequency-modulated-saws.wav?cb=3952785457" type="audio/wav"></audio></p>
<h1 id="Concepts">Concepts</h1>
<h2 id="Environment">Environment</h2><p>An environment defines properties such as the sample rate and the home directory of the synthesizer.</p>
<h2 id="Module">Module</h2><p>Modules are creating the sounds of the synthesizer.
Modules do have a name, inputs, outputs and a shutdown function. The inputs/outputs are represented by keywords and are so called sockets. The shutdown function can be used to release resources 
that have been allocated by the module.</p>
<p>Beside the input/output sockets a module can also expose "state sockets".
State sockets represent internal states of the module. These sockets are not accessible when connecting modules with each other. Their purpose is to support debugging/analyzation of a module, for example by writing certain states to a CSV file.</p>
<p>A module is represented by a property list. This list provides functions such as to get the input sockets, to get the output sockets, to get the state sockets, 
to set input values, to retrieve output values, to update the module, to shutdown the module and so on.</p>
<p>A module must provide a factory/instantiation function. The typical name of this function is "make-module". When a module is added to the synthesizer then not the 
    readily instantiated module is passed, but its factory function. This function is called by the synthesizer. The synthesizer passes the module name, 
    the environment and any arbitrary initialization parameters to it.</p>
<p>For each input/output socket that a module exposes, it must provide a corresponding setter/getter function. When processing an update, the synthesizer sets the inputs of the module via successive calls to the input setters. An input setter must not change the current outputs of the module. When all inputs have been set, the synthesizer calls the update function of the module, which has no parameters. The update function sets the module-outputs according to the previously set inputs.</p>
<h3 id="Example: A module">Example: A module</h3><p><pre><code>(defpackage :cl-synthesizer-examples-adder-2
  (:use :cl)
  (:export :make-module))
(in-package :cl-synthesizer-examples-adder-2)

(defun make-module (name environment)
  &quot;Adder module with 2 inputs&quot;
  (declare (ignore name environment))
  (let ((input-1 nil) (input-2 nil) (cur-output nil))
    (let ((inputs
            (list
             :input-1 (list
                       :set (lambda (value) (setf input-1 value))
                       :get (lambda() input-1))
             :input-2 (list
                       :set (lambda (value) (setf input-2 value))
                       :get (lambda() input-2))))
          (outputs
            (list
             :sum (list :get (lambda() cur-output)))))
      (list
       :inputs (lambda() inputs)
       :outputs (lambda() outputs)
       :update (lambda () (setf cur-output (+ input-1 input-2)))))))</code></pre></p>
<h3 id="Example: A module based on other modules">Example: A module based on other modules</h3><p><pre><code>(defpackage :cl-synthesizer-examples-adder-4
  (:use :cl)
  (:export :make-module))
(in-package :cl-synthesizer-examples-adder-4)

(defun make-module (name environment)
  &quot;Adder module with 4 inputs&quot;
  (declare (ignore name))
  ;; create a rack
  (let ((rack (cl-synthesizer:make-rack :environment environment)))

    ;; add modules
    (cl-synthesizer:add-module rack &quot;ADDER-1&quot; #'cl-synthesizer-examples-adder-2:make-module)
    (cl-synthesizer:add-module rack &quot;ADDER-2&quot; #'cl-synthesizer-examples-adder-2:make-module)
    (cl-synthesizer:add-module rack &quot;MAIN-ADDER&quot; #'cl-synthesizer-examples-adder-2:make-module)

    ;; patch modules
    (cl-synthesizer:add-patch rack &quot;ADDER-1&quot; :sum &quot;MAIN-ADDER&quot; :input-1)
    (cl-synthesizer:add-patch rack &quot;ADDER-2&quot; :sum &quot;MAIN-ADDER&quot; :input-2)
    
    ;; define rack inputs
    (cl-synthesizer:add-rack-input rack :input-1 &quot;ADDER-1&quot; :input-1)
    (cl-synthesizer:add-rack-input rack :input-2 &quot;ADDER-1&quot; :input-2)
    (cl-synthesizer:add-rack-input rack :input-3 &quot;ADDER-2&quot; :input-1)
    (cl-synthesizer:add-rack-input rack :input-4 &quot;ADDER-2&quot; :input-2)

    ;; define rack output
    (cl-synthesizer:add-rack-output rack :sum &quot;MAIN-ADDER&quot; :sum)

    ;; return the rack
    rack))</code></pre></p>
<h2 id="Rack">Rack</h2><p>Racks are holding modules and their connections with each other. The connections are so called "Patches".</p>
<h3 id="Example">Example</h3><p><pre><code>(defpackage :cl-synthesizer-examples-adder-rack
  (:use :cl))
(in-package :cl-synthesizer-examples-adder-rack)


(defun make-example-rack ()
  (let ((rack (cl-synthesizer:make-rack :environment (cl-synthesizer:make-environment))))
    (cl-synthesizer:add-module rack &quot;ADDER&quot; #'cl-synthesizer-examples-adder-4:make-module)
    ;; add rack inputs
    (cl-synthesizer:add-rack-input rack :input-1 &quot;ADDER&quot; :input-1)
    (cl-synthesizer:add-rack-input rack :input-2 &quot;ADDER&quot; :input-2)
    (cl-synthesizer:add-rack-input rack :input-3 &quot;ADDER&quot; :input-3)
    (cl-synthesizer:add-rack-input rack :input-4 &quot;ADDER&quot; :input-4)
    ;; add rack output
    (cl-synthesizer:add-rack-output rack :sum &quot;ADDER&quot; :sum)
    rack))

(defun run-example ()
  (let ((rack (make-example-rack)))
    (let ((rack-inputs (funcall (getf rack :inputs)))
          (rack-outputs (funcall (getf rack :outputs))))
      ;; set inputs
      (let ((input-setter (getf (getf rack-inputs :input-1) :set)))
        (funcall input-setter 10))
      (let ((input-setter (getf (getf rack-inputs :input-2) :set)))
        (funcall input-setter 20))
      (let ((input-setter (getf (getf rack-inputs :input-3) :set)))
        (funcall input-setter 30))
      (let ((input-setter (getf (getf rack-inputs :input-4) :set)))
        (funcall input-setter 40))
      ;; update
      (cl-synthesizer:update rack)
      ;; print output of rack
      (let ((sum (funcall (getf (getf rack-outputs :sum) :get))))
        (format t &quot;~%Sum:~a~%&quot; sum))
      ;; shutdown
      (cl-synthesizer:shutdown rack))))

;; (run-example)</code></pre></p>
<h1 id="API">API</h1>
<h2 id="Environment-1">Environment</h2>
<h3 id="make-environment">make-environment</h3><b>cl-synthesizer:make-environment</b>&nbsp;(&key (sample-rate 44100) (home-directory nil))<p>Creates an environment. An enviroment is a property list with the following keys:
    <ul>
	<li>:sample-rate Sample rate of the synthesizer.</li>
	<li>:home-directory The root output directory of files generated by the synthesizer. Default value is the home directory of the current user. Can be overwritten via cl-synthesizer:*home-directory*.</li>
    </ul></p>
<h3 id="*home-directory*">*home-directory*</h3><b>cl-synthesizer:*home-directory*</b><p>Optional home-directory setting of cl-synthesizer. Overrides the home-directory argument passed to make-environment.</p>
<h2 id="Module-1">Module</h2>
<h3 id="get-module-name">get-module-name</h3><b>cl-synthesizer:get-module-name</b>&nbsp;(module)<p>Returns the name of a module.</p>
<h3 id="get-module-rack">get-module-rack</h3><b>cl-synthesizer:get-module-rack</b>&nbsp;(module)<p>Returns the rack to which a module belongs.</p>
<h3 id="update">update</h3><b>cl-synthesizer:update</b>&nbsp;(module)<p>Calls the update function of a module.</p>
<h3 id="shutdown">shutdown</h3><b>cl-synthesizer:shutdown</b>&nbsp;(module)<p>Calls the (optional) shutdown function of a module.</p>
<h3 id="is-rack">is-rack</h3><b>cl-synthesizer:is-rack</b>&nbsp;(module)<p>Returns t if the given module represents a rack.</p>
<h2 id="Rack-1">Rack</h2>
<h3 id="make-rack">make-rack</h3><b>cl-synthesizer:make-rack</b>&nbsp;(&key environment)<p>Creates a rack.<p>The function has the following parameters:
    <ul>
	<li>:environment The environment.</li>
    </ul></p>
    Returns the rack.</p>
<h3 id="get-environment">get-environment</h3><b>cl-synthesizer:get-environment</b>&nbsp;(rack)<p>Returns the environment of the rack.</p>
<h3 id="add-module">add-module</h3><b>cl-synthesizer:add-module</b>&nbsp;(rack module-name module-fn &rest args)<p>Adds a module to a rack. <p>The function has the following parameters:
    <ul>
	<li>rack The rack.</li>
	<li>module-name Unique name of the module, for example "VCO-1". If the name
	    is already used by another module an assembly-error is signalled.</li>
	<li>module-fn A function that instantiates the module. This function is
	    called by the rack with the following parameters:
	    <ul>
		<li>name Name of the module.</li>
		<li>environment The synthesizer environment.</li>
		<li>module-args Any additional arguments passed to add-module.</li>
	    </ul>
	    The module instantiation function must return a property list with the following keys:
	    <ul>
		<li>:inputs A function with no parameters that returns a property list defining the
                    input sockets of the module. An input socket consists of a keyword and a property list with the following keys:
                    <ul>
                    <li>:set A function with one parameter to set the input value.</li>
                    <li>:get A function with no parameters to get the current input value.</li>
                    </ul>
                </li>
		<li>:outputs A function with no parameters that returns a property list defining
                    the output sockets of the module. An output socket consists of a keyword and a property list with the following keys:
                    <ul>
                    <li>:get A function with no parameters to get the current output value.</li>
                    </ul>
                </li>
		<li>:update A function with no parameters that updates the outputs according to the previously set inputs.</li>
		<li>:shutdown An optional function with no parameters that is called when the rack
		    is shutting down.</li>
                <li>:state An optional function that can be used to expose internal states 
                    of the module, for example a VCO may expose its frequency. The function has one 
                    parameter that consists of a keyword identifying the requested state, for 
                    example :frequency.</li>
	    </ul>
	</li>
	<li>&rest args Arbitrary additional arguments to be passed to the module instantiation function.
	    These arguments typically consist of keyword parameters.</li>
    </ul></p>
    Returns the module.</p>
<h3 id="get-module">get-module</h3><b>cl-synthesizer:get-module</b>&nbsp;(rack path)<p>Get a module by its name or path. <p>The function has the following parameters:
    <ul>
      <li>rack The rack.</li>
      <li>path The path of the module. Examples:
       <ul>
         <li>"VCO" Module "VCO" of the given rack</li>
         <li>'("VOICE-1" "VCO") Module "VCO" of the sub-rack "VOICE-1"</li>
       </ul></ul></p>
   Returns the module or nil.</p>
<h3 id="get-modules">get-modules</h3><b>cl-synthesizer:get-modules</b>&nbsp;(rack)<p>Returns the modules of a rack.</p>
<h3 id="add-patch">add-patch</h3><b>cl-synthesizer:add-patch</b>&nbsp;(rack output-module-name output-socket input-module-name input-socket)<p>Adds a patch to the rack. A patch is an unidirectional connection between an output socket
    of a source module and an input socket of a destination module.<p>
    The function has the following parameters:
    <ul>
	<li>rack The rack.</li>
	<li>output-module-name Name of the output (source) module.</li>
	<li>output-socket A keyword representing one of the output sockets of the
	    output module.</li>
	<li>input-module-name Name of the input (destination) module.</li>
	<li>input-socket A keyword representing one of the input sockets of the
	    input module.</li>
    </ul></p>
    <p>The rack signals an assembly-error in cases such as:
    <ul>
	<li>A module with the given output name does not exist.</li>
	<li>A module with the given input name does not exist.</li>
	<li>The given output-socket is already connected with a module.</li>
	<li>The given output-socket is not exposed by the output module.</li>
	<li>The given input-socket is already connected with a module.</li>
	<li>The given input-socket is not exposed by the input module.</li>
    </ul></p></p>
<h3 id="get-patches">get-patches</h3><b>cl-synthesizer:get-patches</b>&nbsp;(rack)<p>Returns a list of the patches of a rack. Each patch is represented by a property list with the following keys:
   <ul>
     <li>:output-name Name of the output module.</li>
     <li>:output-socket Output socket. </li>
     <li>:input-name Name of the input module. </li>
     <li>:input-socket Input socket.</li>
   </ul></p>
<h3 id="add-rack-input">add-rack-input</h3><b>cl-synthesizer:add-rack-input</b>&nbsp;(rack rack-input-socket input-module-name input-socket)<p>Exposes an input socket of a module as an input socket of the rack. <p>The function has the following parameters:
   <ul>
    <li>rack The rack.</li>
    <li>rack-input-socket A keyword representing the input socket of the rack.</li>
    <li>input-module-name Name of the module whose input is to be exposed.</li>
    <li>input-socket A keyword representing one of the inputs of the module.</li>
  </ul></p></p>
<h3 id="add-rack-output">add-rack-output</h3><b>cl-synthesizer:add-rack-output</b>&nbsp;(rack rack-output-socket output-module-name output-socket)<p>Exposes an output socket of a module as an output socket of the rack. <p>The function has the following parameters:
   <ul>
    <li>rack The rack.</li>
    <li>rack-output-socket A keyword representing the output socket of the rack.</li>
    <li>output-module-name Name of the module whose output is to be exposed.</li>
    <li>output-socket A keyword representing one of the outputs of the module.</li>
  </ul></p></p>
<h3 id="add-hook">add-hook</h3><b>cl-synthesizer:add-hook</b>&nbsp;(rack hook)<p>Adds a hook to a rack. <p>The function has the following parameters:
   <ul>
      <li>rack The rack.</li>
      <li>hook The hook. A hook consists a property list with the following keys:
         <ul>
           <li>:updating An optional function with no parameters that is called before the rack is updated. This function can be used to set rack inputs.</li>
           <li>:updated An optional function with no parameters that is called after the rack has been updated.</li>
          <li>:shutdown An optional function with no parameters that is called when the rack is shutting down.</li></ul>
   </ul></p>
   Hooks must not add/remove modules or patches.</p>
<h3 id="play-rack">play-rack</h3><b>cl-synthesizer:play-rack</b>&nbsp;(rack &key duration-seconds)<p>A utility function that "plays" the rack by consecutively calling its update function
    for a given number of "ticks". <p>The function has the following parameters:
    <ul>
	<li>rack The rack.</li>
	<li>:duration-seconds Duration in seconds of how long to play the rack. If for
	    example the duration is 2 seconds and the sample rate of the rack as declared
	    by its environment is 44100, then the update function of the rack will be called 88200 times.</li>
    </ul></p></p>
<h2 id="Modules">Modules</h2>
<h3 id="System">System</h3><b>cl-synthesizer-modules-system:make-module</b>&nbsp;(name environment &key)<p>Creates a module which exposes runtime information of its rack.
   <p>The function has the following parameters:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
    </ul></p>
    <p>The module has no inputs.</p>
    <p>The module has the following outputs:
    <ul>
       <li>:sample-rate The sample rate of the rack.</li>
       <li>:ticks The tick number that is being processed. The first tick has the number 0.</li>
       <li>:milliseconds The time in milliseconds that has passed since the first tick.</li>
       <li>:seconds The time in seconds that has passed since the first tick.</li>
    </ul></p></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-system-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-system-example-1)

(defun example ()
  &quot;System example&quot;
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment))))
    
    (cl-synthesizer:add-module
     rack &quot;SYSTEM&quot;
     #'cl-synthesizer-modules-system:make-module)
    
    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-csv-file-agent:make-backend
     '((&quot;SYSTEM&quot; :output-socket :ticks :name &quot;ticks&quot;)
       (&quot;SYSTEM&quot; :output-socket :milliseconds :name &quot;milliseconds&quot;)
       (&quot;SYSTEM&quot; :output-socket :seconds :name &quot;seconds&quot;)
       (&quot;SYSTEM&quot; :output-socket :sample-rate :name &quot;sample-rate&quot;))
     :filename &quot;cl-synthesizer-examples/system-example-1.csv&quot;
     :add-header t
     :column-separator &quot;,&quot;)

    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 2)))

;; (run-example)</code></pre></p>
<h3 id="VCO">VCO</h3><b>cl-synthesizer-modules-vco:make-module</b>&nbsp;(name environment &key base-frequency v-peak (cv-lin-hz-v 0.0) (duty-cycle 0.5)
 (phase-offset 0.0) (f-max 12000.0) (wave-forms nil) (sync-threshold 2.5))<p>Creates a Voltage Controlled Oscillator module with 1V/Octave and linear frequency modulation
   inputs. The oscillator has through-zero support.
   <p>The function has the following parameters:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:base-frequency The frequency emitted by the oscillator when all frequency control 
           voltages are 0.</li>
	<li>:f-max Absolute value of the maximum frequency of the oscillator. f-max must be greater than 0.</li>
	<li>:cv-lin-hz-v Frequency/Volt setting for the linear frequency modulation input :cv-lin.</li>
	<li>:v-peak Absolute value of the output peak voltage emitted by the oscillator.</li>
	<li>:duty-cycle The duty cycle of the square wave. 0 <= duty-cycle <= 1.</li>
	<li>:phase-offset Phase offset in radians.</li>
        <li>:wave-forms A list of keywords that declares the wave forms that are to be exposed by 
          the module. Each keyword must be one of :sine, :saw, :triangle or :square. By default
          the module exposes all wave forms. Declaring the required wave forms is highly recommended
          as this can improve the execution speed of the module significantly (up to 50%).</li>
        <li>:sync-threshold Minimum value of the :sync input that indicates 
            that a phase reset is to be applied.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
	<li>:cv-exp Exponential frequency control voltage. For a given base-frequency of 440Hz a
	    control voltage of 1.0 results in a frequency of 880Hz and a control
	    voltage of -1.0 results in a frequency of 220Hz.
	</li>
        <li>:cv-lin Bipolar linear frequency control voltage. Example: If the :cv-lin-hz-v setting
           of the oscillator is 77Hz a :cv-lin input value of 2.0V results in a frequency of 154Hz and 
           a :cv-lin input value of -2.0V results in a frequency of -154Hz.</li>
        <li>:sync Indicator if the phase is to be reset. See also :sync-threshold constructor parameter.</li>
    </ul>
    The frequency of the oscillator is calculated by adding the frequencies resulting from the
    :cv-lin and :cv-exp inputs. The frequency is clipped according to the :f-max setting.</p>
    <p>The module has the following outputs (depending on the :wave-forms parameter):
    <ul>
	<li>:sine A sine wave.</li>
	<li>:triangle A triangle wave.</li>
	<li>:saw A saw wave.</li>
	<li>:square A square wave.</li>
    </ul></p>
    <p>The module exposes the following states via the state function:
       <ul>
          <li>:frequency The current frequency of the module.</li>
          <li>:linear-frequency The current linear frequency portion of the module.</li>
          <li>:exponential-frequency The current exponential frequency portion of the module.</li>
          <li>:phase The current phase in radians (0..2PI).</li>
       </ul>
    </p></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-vco-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-vco-example-1)

(defun example ()
  &quot;Write all wave forms to a Wave and a CSV file&quot;
  (let ((rack (cl-synthesizer:make-rack :environment (cl-synthesizer:make-environment))))
    (cl-synthesizer:add-module
     rack
     &quot;VCO&quot;
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 10.0 :v-peak 5.0)

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-wave-file-agent:make-backend
     '((&quot;VCO&quot; :output-socket :sine)
       (&quot;VCO&quot; :output-socket :triangle)
       (&quot;VCO&quot; :output-socket :saw)
       (&quot;VCO&quot; :output-socket :square))
     :filename &quot;cl-synthesizer-examples/vco-example-1.wav&quot;
     :v-peak 5.0)

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-csv-file-agent:make-backend
     '((&quot;VCO&quot; :output-socket :sine :name &quot;Sine&quot;)
       (&quot;VCO&quot; :output-socket :triangle :name &quot;Triangle&quot;)
       (&quot;VCO&quot; :output-socket :saw :name &quot;Saw&quot;)
       (&quot;VCO&quot; :output-socket :square :name &quot;Square&quot;))
     :filename &quot;cl-synthesizer-examples/vco-example-1.csv&quot;
     :add-header t
     :column-separator &quot;,&quot;)
    
    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 1)))

;; (run-example)</code></pre></p>
<h3 id="VCA">VCA</h3><b>cl-synthesizer-modules-vca:make-module</b>&nbsp;(name environment &key cv-max (initial-gain 0.0) (exponential nil))<p>Creates a Voltage Controlled Amplifier/Attenuator module. The VCA multiplies an
    incoming signal with a factor of 0..1. <p>The function has the following parameters:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:cv-max The value of the effective amplification control voltage that represents the maximum
	    amplification of 1.0.</li>
	<li>:initial-gain An offset that is added to the amplification control voltage.</li>
        <li>:exponential If t then the amplification will have an exponential characteristic.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
	<li>:cv Amplification control voltage.</li>
	<li>:input Input signal to be amplified.</li>
	<li>:gain An offset that is added to the amplification control voltage.</li>
    </ul>
    The effective amplification voltage is v = :cv + :gain + :initial-gain, where 0.0 <= v <= :cv-max.</p>
    <p>The module has the following outputs:
    <ul>
	<li>:output Amplified input signal.</li>
    </ul></p></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-vca-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-vca-example-1)

(defun example ()
  &quot;Amplification of a 10kHz sine wave with a bipolar triangular signal.&quot;
  (let ((rack (cl-synthesizer:make-rack :environment (cl-synthesizer:make-environment))))

    ;; Set up oscillator modulating the amplification
    (cl-synthesizer:add-module
     rack &quot;LFO-CV&quot;
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 0.5
     :v-peak 5.0)

    ;; set up oscillator providing the audio signal
    (cl-synthesizer:add-module
     rack &quot;VCO-AUDIO&quot;
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 5.0
     :v-peak 5.0)

    ;; Set up VCA
    (cl-synthesizer:add-module
     rack &quot;VCA&quot;
     #'cl-synthesizer-modules-vca:make-module
     :cv-max 5.0
     :exponential t)

    ;; Add patches
    (cl-synthesizer:add-patch rack &quot;VCO-AUDIO&quot; :sine &quot;VCA&quot; :input)
    (cl-synthesizer:add-patch rack &quot;LFO-CV&quot; :triangle &quot;VCA&quot; :cv)

    ;; Write VCA inputs/outputs to a CSV file
    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-csv-file-agent:make-backend
     '((&quot;VCA&quot; :input-socket :cv :name &quot;CV&quot;)
       (&quot;VCA&quot; :input-socket :input :name &quot;Input&quot;)
       (&quot;VCA&quot; :output-socket :output :name &quot;Output&quot;))
     :filename &quot;cl-synthesizer-examples/vca-example-1.csv&quot;)
    
    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 5.0)))

;; (run-example)</code></pre></p>
<h3 id="ADSR">ADSR</h3><b>cl-synthesizer-modules-adsr:make-module</b>&nbsp;(name environment &key attack-time-ms attack-target-output decay-time-ms
 decay-target-output release-time-ms (gate-threshold 2.5)
 (backward-coupled nil) (exponential nil))<p>Creates an envelope generator module with the phases Attack, Decay, Sustain and Release.
    <p>The function has the following parameters:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:attack-time-ms Duration of the attack phase in milliseconds.</li>
	<li>:attack-target-output Target value of the attack phase.</li>
	<li>:decay-time-ms Duration of the decay phase in milliseconds.</li>
	<li>:decay-target-output Target value of the decay phase.</li>
	<li>:release-time-ms Duration of the release phase in milliseconds. The release phase climbs to 0.0.</li>
	<li>:gate-threshold Minimum value of the :gate input that indicates that the gate is on.</li>
        <li>:backward-coupled If t then the output signal of the envelope will be connected with 
            the input of the attack phase. This can be used to avoid sudden jumps of the envelope 
            as the attack phase by default starts at 0.0.</li>
        <li>:exponential If t then the envelope will have exponential characteristic.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
	<li>:gate The gate signal (see also :gate-threshold). The envelope starts working when the
	gate input switches to "on" and enters into the release phase when it switches to "off".</li>
	<li>:attack-cv-time Modulates the climbing time of the attack phase. The resulting time is 1000ms per Volt.</li>
	<li>:release-cv-time Modulates the climbing time of the release phase. The resulting time is 1000ms per Volt.</li>
    </ul></p>
    <p>The module has the following outputs:
    <ul>
	<li>:cv The envelope.</li>
    </ul></p></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-adsr-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-adsr-example-1)

(defun make-voice (name environment &amp;key exponential)
  (declare (ignore name))
  (let ((rack (cl-synthesizer:make-rack :environment environment)))

    (cl-synthesizer:add-module
     rack &quot;ADSR&quot;
     #'cl-synthesizer-modules-adsr:make-module
     :attack-time-ms 500 :attack-target-output 5.0
     :decay-time-ms 250 :decay-target-output -3.0
     :release-time-ms 1000
     :exponential exponential)

    (cl-synthesizer:add-rack-input rack :gate &quot;ADSR&quot; :gate)
    (cl-synthesizer:add-rack-output rack :adsr-out &quot;ADSR&quot; :cv)

    rack))

(defun example ()
  &quot;ADSR example. Linear vs. Exponential&quot;
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment))))
    
    (cl-synthesizer:add-module
     rack &quot;MIDI-SEQUENCER&quot;
     #'cl-synthesizer-modules-midi-sequencer:make-module :events
     (list 
      (list :timestamp-milli-seconds 0
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-on-event :channel 1 :note-number 69 :velocity 100)))
      (list :timestamp-milli-seconds 1500
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-off-event :channel 1 :note-number 69 :velocity 100)))))

    (cl-synthesizer:add-module
     rack &quot;MIDI-IFC&quot;
     #'cl-synthesizer-modules-midi-polyphonic-interface:make-module :voice-count 1)

    (cl-synthesizer:add-patch rack &quot;MIDI-SEQUENCER&quot; :midi-events &quot;MIDI-IFC&quot; :midi-events)
    
    (cl-synthesizer:add-module
     rack &quot;GATE-MULTIPLE&quot;
     #'cl-synthesizer-modules-multiple:make-module
     :output-count 2)

    (cl-synthesizer:add-patch rack &quot;MIDI-IFC&quot; :gate-1 &quot;GATE-MULTIPLE&quot; :input)

    (cl-synthesizer:add-module
     rack &quot;LINEAR&quot; #'make-voice :exponential nil)
    (cl-synthesizer:add-patch rack &quot;GATE-MULTIPLE&quot; :output-1 &quot;LINEAR&quot; :gate)
    
    (cl-synthesizer:add-module
     rack &quot;EXPONENTIAL&quot; #'make-voice :exponential t)
    (cl-synthesizer:add-patch rack &quot;GATE-MULTIPLE&quot; :output-2 &quot;EXPONENTIAL&quot; :gate)

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-csv-file-agent:make-backend
     '((&quot;GATE-MULTIPLE&quot; :input-socket :input :name &quot;Gate&quot;)
       (&quot;LINEAR&quot; :output-socket :adsr-out :name &quot;ADSR Linear&quot;)
       (&quot;EXPONENTIAL&quot; :output-socket :adsr-out :name &quot;ADSR Exponential&quot;))
     :filename &quot;cl-synthesizer-examples/adsr-example-1.csv&quot;)
    
    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 3)))

;; (run-example)</code></pre></p>
<h3 id="Multiple">Multiple</h3><b>cl-synthesizer-modules-multiple:make-module</b>&nbsp;(name environment &key output-count)<p>Creates a Multiple module. A multiple passes the value of exactly one input socket
   to as many output sockets as defined by output-count.
   <p>The function has the following parameters:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:output-count The number of output sockets.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
	<li>:input The input signal to be passed to the outputs.</li>
    </ul></p>
    <p>The module has the following outputs:
    <ul>
        <li>:output-1 ... :output-n. Where n is the output-count.</li>
    </ul></p></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-multiple-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-multiple-example-1)

(defun example ()
  &quot;Multiple example&quot;
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment))))
    
    (cl-synthesizer:add-module
     rack &quot;LFO&quot;
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 1.0 :v-peak 1.0)
    
    (cl-synthesizer:add-module rack &quot;MULTIPLE&quot;
                               #'cl-synthesizer-modules-multiple:make-module :output-count 5)
    (cl-synthesizer:add-patch rack &quot;LFO&quot; :sine &quot;MULTIPLE&quot; :input)
    (cl-synthesizer:add-rack-output rack :line-out-1 &quot;MULTIPLE&quot; :output-1)
    (cl-synthesizer:add-rack-output rack :line-out-2 &quot;MULTIPLE&quot; :output-2)

    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 10)))

;; (run-example)</code></pre></p>
<h3 id="Fixed Output">Fixed Output</h3><b>cl-synthesizer-modules-fixed-output:make-module</b>&nbsp;(name environment &key value (output-socket out))<p>Creates a module with a fixed output value.
   <p>The function has the following parameters:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:value The value of the module output.</li>
	<li>:output-socket Optional keyword that declares the output socket
	    identifier to be exposed by the module.</li>
    </ul></p>
    The module has no inputs.
    The module has one output socket according to the :output-socket parameter.</p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-fixed-output-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-fixed-output-example-1)

(defun example ()
  &quot;Fixed-Output example&quot;
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment))))
    
    (cl-synthesizer:add-module
     rack &quot;FIXED-OUTPUT&quot;
     #'cl-synthesizer-modules-fixed-output:make-module
     :value 3.0
     :output-socket :fixed)
    
    (cl-synthesizer:add-rack-output rack :line-out &quot;FIXED-OUTPUT&quot; :fixed)

    rack))

(defun run-example ()
  (cl-synthesizer:play-rack (example) :duration-seconds 1))

;; (run-example)</code></pre></p>
<h3 id="Adder">Adder</h3><b>cl-synthesizer-modules-adder:make-module</b>&nbsp;(name environment &key input-count)<p>Creates a simple voltage adder module. 
   <p>The function has the following parameters:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:input-count The number of input sockets.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
        <li>:input-1 ... :input-n. Where n is the input-count. Input values
        not of type number are ignored.</li>
    </ul></p>
    <p>The module has the following outputs:
    <ul>
	<li>:output The output consisting of the sum of the inputs.</li>
    </ul></p></p>
<h3 id="Mixer">Mixer</h3><b>cl-synthesizer-modules-mixer:make-module</b>&nbsp;(name environment &key channel-count channel-cv-max channel-cv-gain main-cv-max
 main-cv-gain)<p>Creates a mixer module. The mixer provides an attenuator for each input and a main
   attenuator for the mixer output. All attenuators have linear amplification
   characteristic. <p>The function has the following parameters:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:channel-count The number of channels.</li>
        <li>:channel-cv-max The value of a channel attenuation control voltage that 
        represents an amplification of 1.0.</li>
        <li>:channel-cv-gain An offset that is added to the channel attenuation 
        control voltage.</li>
        <li>:main-cv-max The value of the main attenuation input that 
        represents an amplification of 1.0.</li>
        <li>:main-cv-gain An offset that is added to the main attenuation 
        control voltage.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
        <li>:channel-1 ... :channel-n. Channel input signal, where n is the channel-count.</li>
        <li>:cv-1 ... :cv-n. Channel attenuation control voltage, where n is the channel-count.</li>
        <li>:cv-main Attenuation control voltage of the mixer output.</li> 
    </ul></p>
    <p>The module has the following outputs:
    <ul>
	<li>:output The output consisting of the sum of the inputs.</li>
    </ul></p></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-mixer-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-mixer-example-1)

(defun example ()
  &quot;Mixer example.&quot;
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment))))

    ;;
    ;; add modules...
    ;;
    
    (cl-synthesizer:add-module
     rack &quot;MIXER&quot; #'cl-synthesizer-modules-mixer:make-module
     :channel-count 2
     :channel-cv-max 5.0
     :channel-cv-gain 5.0
     :main-cv-max 5.0
     :main-cv-gain 2.5)
    
    (cl-synthesizer:add-patch rack &quot;VOICE-1&quot; :audio &quot;MIXER&quot; :channel-1)
    (cl-synthesizer:add-patch rack &quot;VOICE-2&quot; :audio &quot;MIXER&quot; :channel-2)
    (cl-synthesizer:add-rack-output rack :line-out &quot;MIXER&quot; :output)
    
    rack))</code></pre></p>
<h3 id="Trigger">Trigger</h3><b>cl-synthesizer-modules-trigger:make-module</b>&nbsp;(name environment &key trigger-threshold pulse-voltage)<p>Creates a Voltage to Trigger Converter module. 
   The module fires a one clock cycle long pulse when input voltage >= trigger-threshold
   and then waits that the input voltage descends below trigger-threshold before the next
   pulse can be triggered. The module can for example be used to generate a trigger
   out of a gate signal. <p>The function has the following parameters:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:trigger-threshold The minimum value of the input which triggers a pulse.</li>
	<li>:pulse-voltage The voltage of the pulse.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
	<li>:input The input voltage.</li>
    </ul></p>
    <p>The module has the following outputs:
    <ul>
        <li>:output The output voltage (zero or pulse-voltage).</li>
    </ul></p></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-trigger-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-trigger-example-1)

(defun example ()
  &quot;Emit trigger signal based on sine input&quot;
  (let ((rack (cl-synthesizer:make-rack :environment (cl-synthesizer:make-environment))))
    (cl-synthesizer:add-module
     rack
     &quot;VCO&quot;
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 5.0 :v-peak 5.0)

    (cl-synthesizer:add-module
     rack
     &quot;TRIGGER&quot;
     #'cl-synthesizer-modules-trigger:make-module
     :trigger-threshold 4.9 :pulse-voltage 3.0)

    (cl-synthesizer:add-patch rack &quot;VCO&quot; :sine &quot;TRIGGER&quot; :input)
    
    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-wave-file-agent:make-backend
     '((&quot;TRIGGER&quot; :input-socket :input)
       (&quot;TRIGGER&quot; :output-socket :output))
     :filename &quot;cl-synthesizer-examples/trigger-example-1.wav&quot;
     :v-peak 5.0)

    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 2)))

;; (run-example)</code></pre></p>
<h3 id="Ramp">Ramp</h3><b>cl-synthesizer-modules-ramp:make-module</b>&nbsp;(name environment &key time-ms target-output (gate-state nil)
 (trigger-threshold 2.5) (gate-threshold 2.5) (exponential nil))<p>Creates a module whose output climbs from a given input value to a given output value
    in a given time. Main purpose of this module is to create envelope generators by chaining
    multiple ramp and sustain modules. <p>The function has the following parameters:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:time-ms Default climbing time (duration) in milliseconds.</li>
	<li>:target-output Desired target output value. Due to the time resolution given by the sample-rate 
	    of the environment the ramp may stop at an output value a little bit smaller or 
	    greater than the desired target-output value.</li>
	<li>:gate-state Required state of the Gate input. One of :on, :off, nil</li>
	<li>:trigger-threshold Minimum value of the :trigger input that indicates that the trigger is active.</li>
	<li>:gate-threshold Minimum value of the :gate input that indicates that the gate is on.</li>
        <li>:exponential If t then the ramp will climb with an exponential characteristic.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
	<li>:trigger Trigger input. If the trigger is active (see also :trigger-threshold), the module samples
	    its current input value and begins climbing to the desired target output value.</li>
	<li>:input Input value.</li>
	<li>:pass-through If value is >= 5.0 the module passes through its input value.</li>
	<li>:gate A gate signal (see also :gate-threshold).</li>
	<li>:cv-time NIL or climbing time (duration) of the ramp. The resulting time is 1000ms per Volt.</li>
    </ul></p>
    <p>The module has the following outputs:
    <ul>
	<li>:output Output value of the module. The initial output value is 0.0.</li>
	<li>:busy A value >= 5.0 indicates that the module is busy by either passing through
	its input value or climbing to the target output value.</li>
	<li>:done A trigger signal that jumps to 5.0 for the length of one clock cycle when the ramp has
	finished.</li>
	<li>:gate Passed through :gate input. Purpose of this output is to support more convenient
	    chaining of ramp and sustain modules.</li>
    </ul></p>
    When the ramp aborts due to a toggling Gate signal or when its supposed
    duration has been exceeded due to time modulation then the output value does not jump 
    to the desired target-output but stays at its current value.<br><br>
    This module has been inspired by <a href="https://github.com/dhemery/DHE-Modules/wiki/Multi-Stage-Envelopes">dhemery</a></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-ramp-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-ramp-example-1)

(defun make-voice (name environment &amp;key (exponential nil))
  (declare (ignore name))
  (let ((rack
         (cl-synthesizer:make-rack :environment environment)))

    (cl-synthesizer:add-module
     rack &quot;ATTACK&quot;
     #'cl-synthesizer-modules-ramp:make-module
     :time-ms 700 :target-output 5.0 :gate-state nil :exponential exponential)

    (cl-synthesizer:add-module
     rack &quot;DECAY&quot;
     #'cl-synthesizer-modules-ramp:make-module
     :time-ms 500 :target-output -2.5 :exponential exponential)
    
    (cl-synthesizer:add-rack-input rack :trigger &quot;ATTACK&quot; :trigger)
    (cl-synthesizer:add-patch rack &quot;ATTACK&quot; :busy &quot;DECAY&quot; :pass-through)
    (cl-synthesizer:add-patch rack &quot;ATTACK&quot; :output &quot;DECAY&quot; :input)
    (cl-synthesizer:add-patch rack &quot;ATTACK&quot; :done &quot;DECAY&quot; :trigger)

    (cl-synthesizer:add-rack-output rack :output &quot;DECAY&quot; :output)

    rack))

(defun example ()
  &quot;Linear and Exponential Ramp&quot;
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment))))

    (cl-synthesizer:add-module
     rack &quot;VCO&quot;
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 0.5 :v-peak 5.0)

    (cl-synthesizer:add-module
     rack &quot;TRIGGER&quot;
     #'cl-synthesizer-modules-trigger:make-module
     :trigger-threshold 4.9 :pulse-voltage 5.0)

    (cl-synthesizer:add-patch rack &quot;VCO&quot; :square &quot;TRIGGER&quot; :input)
    
    (cl-synthesizer:add-module
     rack &quot;TRIGGER-MULTIPLE&quot;
     #'cl-synthesizer-modules-multiple:make-module
     :output-count 2)

    (cl-synthesizer:add-patch rack &quot;TRIGGER&quot; :output &quot;TRIGGER-MULTIPLE&quot; :input)
    
    (cl-synthesizer:add-module
     rack &quot;LINEAR&quot; #'make-voice :exponential nil)
    (cl-synthesizer:add-patch rack &quot;TRIGGER-MULTIPLE&quot; :output-1 &quot;LINEAR&quot; :trigger)
    
    (cl-synthesizer:add-module
     rack &quot;EXPONENTIAL&quot; #'make-voice :exponential t)
    (cl-synthesizer:add-patch rack &quot;TRIGGER-MULTIPLE&quot; :output-2 &quot;EXPONENTIAL&quot; :trigger)

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-csv-file-agent:make-backend
     '((&quot;LINEAR&quot; :output-socket :output :name &quot;Lin Out&quot;)
       (&quot;EXPONENTIAL&quot; :output-socket :output :name &quot;Exp Out&quot;))
     :filename &quot;cl-synthesizer-examples/ramp-example-1.csv&quot;)
    
    rack))

(defun run-example ()
  (let ((rack (example))) (cl-synthesizer:play-rack rack :duration-seconds 5)))

;; (run-example)</code></pre></p>
<h3 id="Sustain">Sustain</h3><b>cl-synthesizer-modules-sustain:make-module</b>&nbsp;(name environment &key (trigger-threshold 2.5) (gate-threshold 2.5))<p>Creates a module which holds a given input as long as its gate input is "on".
    Main purpose of this module is to create envelope generators by chaining
    multiple ramp and sustain modules. <p>The function has the following parameters:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:trigger-threshold Minimum value of the :trigger input that indicates that the trigger is active.</li>
	<li>:gate-threshold Minimum value of the :gate input that indicates that the gate is on.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
	<li>:trigger Trigger input. If the trigger is active (see also :trigger-threshold), the module samples
	    its current input value and begins passing it to its output socket.</li>
	<li>:input Input value.</li>
	<li>:pass-through If value is >= 5.0 the module passes through its input value.</li>
	<li>:gate A gate signal (see also :gate-threshold).</li>
    </ul></p>
    <p>The module has the following outputs:
    <ul>
	<li>:output Output value of the module. The initial output value is 0.0.</li>
	<li>:busy A value >= 5.0 indicates that the module is busy by either passing through
	    its input value or holding the sampled input value until the gate input falls to zero.</li>
	<li>:done A trigger signal that jumps to 5.0 for the length of one clock cycle when the sustain cycle
	    has finished.</li>
	<li>:gate Passed through :gate input. Purpose of this output is to support more convenient
	    chaining of ramp and sustain modules.</li>
    </ul></p>
    This module has been inspired by <a href="https://github.com/dhemery/DHE-Modules/wiki/Multi-Stage-Envelopes">dhemery</a></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-sustain-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-sustain-example-1)

(defun example ()
  &quot;Sustain example&quot;
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment))))
    
    ;; Use MIDI sequencer for generation of Gate signals
    (cl-synthesizer:add-module
     rack &quot;MIDI-SEQUENCER&quot;
     #'cl-synthesizer-modules-midi-sequencer:make-module :events
     (list 
      (list :timestamp-milli-seconds 300
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-on-event
                           :channel 1
                           :note-number 69
                           :velocity 100)))
      (list :timestamp-milli-seconds 700
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-off-event
                           :channel 1
                           :note-number 69
                           :velocity 100)))
      (list :timestamp-milli-seconds 1800
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-on-event
                           :channel 1
                           :note-number 69
                           :velocity 100)))
      (list :timestamp-milli-seconds 2100
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-off-event
                           :channel 1
                           :note-number 69
                           :velocity 100)))))

    (cl-synthesizer:add-module
     rack &quot;MIDI-IFC&quot;
     #'cl-synthesizer-modules-midi-polyphonic-interface:make-module :voice-count 1)

    (cl-synthesizer:add-module
     rack &quot;GATE-MULTIPLE&quot;
     #'cl-synthesizer-modules-multiple:make-module :output-count 2)

    (cl-synthesizer:add-module
     rack &quot;TRIGGER&quot;
     #'cl-synthesizer-modules-trigger:make-module
     :trigger-threshold 4.9 :pulse-voltage 5.0)

    (cl-synthesizer:add-module
     rack &quot;VCO&quot;
     #'cl-synthesizer-modules-vco:make-module
     :base-frequency 0.5 :v-peak 5.0)
    
    (cl-synthesizer:add-module
     rack &quot;SUSTAIN&quot;
     #'cl-synthesizer-modules-sustain:make-module)

    (cl-synthesizer:add-patch rack &quot;MIDI-SEQUENCER&quot; :midi-events &quot;MIDI-IFC&quot; :midi-events)
    (cl-synthesizer:add-patch rack &quot;MIDI-IFC&quot; :gate-1 &quot;GATE-MULTIPLE&quot; :input)
    (cl-synthesizer:add-patch rack &quot;GATE-MULTIPLE&quot; :output-1 &quot;TRIGGER&quot; :input)
    (cl-synthesizer:add-patch rack &quot;GATE-MULTIPLE&quot; :output-2 &quot;SUSTAIN&quot; :gate)
    (cl-synthesizer:add-patch rack &quot;TRIGGER&quot; :output &quot;SUSTAIN&quot; :trigger)
    (cl-synthesizer:add-patch rack &quot;VCO&quot; :sine &quot;SUSTAIN&quot; :input)

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-csv-file-agent:make-backend
     '((&quot;MIDI-IFC&quot; :output-socket :gate-1 :name &quot;Gate&quot;)
       (&quot;SUSTAIN&quot; :input-socket :trigger :name &quot;Sustain Trigger In&quot;)
       (&quot;SUSTAIN&quot; :input-socket :input :name &quot;Sustain In&quot;)
       (&quot;SUSTAIN&quot; :output-socket :output :name &quot;Sustain Out&quot;)
       (&quot;SUSTAIN&quot; :output-socket :done :name &quot;Sustain Done Out&quot;))
     :filename &quot;cl-synthesizer-examples/sustain-example-1.csv&quot;)
    
    rack))

(defun run-example ()
  (let ((rack (example))) (cl-synthesizer:play-rack rack :duration-seconds 3)))

;; (run-example)</code></pre></p>
<h3 id="Wave File Writer">Wave File Writer</h3><b>cl-synthesizer-modules-wave-file-writer:make-module</b>&nbsp;(name environment &key channel-count filename v-peak (sample-width 16bit))<p>Creates a Wave File Writer module. Writes files in "Waveform Audio File" ("WAV") format.
    <p>The function has the following parameters:
  <ul>
    <li>name Name of the writer.</li>
    <li>environment The synthesizer environment.</li>
    <li>:channel-count Number of channels.</li>
    <li>:filename The relative path of the file to be written. The filename will be concatenated
        with the base path as defined by the :home-directory property of the environment.</li>
    <li>:v-peak Absolute value of peak voltage.</li>
    <li>:sample-width Resolution of samples. One of :8Bit, :16Bit, :24Bit</li> 
  </ul></p>
  <p>The module has the following inputs:
  <ul>
      <li>:channel-1 ... :channel-n The sample values of the generated frames
	  are written in order :channel-1 ... :channel-n</li>
  </ul></p>
  The module has no outputs.</p>
<h3 id="CSV File Writer">CSV File Writer</h3><b>cl-synthesizer-modules-csv-file-writer:make-module</b>&nbsp;(name environment &key columns filename (column-separator ,) (add-header t))<p>Creates a CSV File Writer module.
    <p>The function has the following parameters:
  <ul>
    <li>name Name of the writer.</li>
    <li>environment The synthesizer environment.</li>
    <li>:columns A list of column definitions. Each colum definition consists of a property list 
        with the following keys:
        <ul>
            <li>:name Name of the column.</li>
            <li>:default-value Default value to be used if current column value is nil.</li>
        </ul>
    </li>
    <li>:filename The relative path of the file to be written. The filename will be concatenated
        with the base path as defined by the :home-directory property of the environment.</li>
    <li>:column-separator The column separator.</li>
    <li>:add-header If t then a header consisting of the column-names will be written.</li>
  </ul></p>
  <p>The module has the following inputs:
  <ul>
      <li>:column-1 ... :column-n Where n is the number of columns.</li>
  </ul></p>
  <p>Due to performance/consing considerations all columns are written using the Lisp-Writer. 
     If a value contains the column separator it will not be quoted. The file is opened on the first 
     call of the update function and closed by the shutdown handler.
  </p>
  The module has no outputs.</p>
<h2 id="Monitors">Monitors</h2><p>Monitors are hook implementations that register themselves at a rack. They are called after a rack has processed an update. They collect data like output socket values and pass them to a so called "Monitor Backend".
  A monitor backend can for example be a CSV-File-Writer.
A monitor backend is a module. It is instantiated by a so called "Monitor Agent".
This agent sits between the monitor and its backend. The agent instantiates the backend
  and defines the mapping of the values collected by the monitor to input sockets of the backend.</p>
<h3 id="add-monitor">add-monitor</h3><b>cl-synthesizer-monitor:add-monitor</b>&nbsp;(rack monitor-agent socket-mappings &rest additional-agent-args)<p>Registers a monitor at a rack.<p>The function has the following parameters:
    <ul>
	<li>rack The rack.</li>
	<li>monitor-agent A function that instantiates the monitor backend.
	    This function is called with the following parameters:
	    <ul>
		<li>name A name.</li>
		<li>environment The synthesizer environment.</li>
		<li>inputs A list of inputs. Each entry consists of the additional
                    settings that have been set at a specific socket mapping, for example
                    the CSV formatting string.</li>
		<li>additional-agent-args Any additional keyword parameters as
		    passed to the monitor function. These parameters can be
		    used to provide backend specific properties, like for example
		    a filename.</li>
	    </ul>
	    The function must return a values object with the following entries:
	    <ul>
		<li>module A property list that implements a module (this is the Monitor-Backend).</li>
		<li>An ordered list of input sockets of the module (the Monitor-Backend), where the first entry represents 
                   the first entry of the socket mappings (e.g. column-1) and so on.</li>
	    </ul>
	</li>
	<li>socket-mappings Declares the input/outputs/states whose values are to be tracked.
            Each entry has the following format:
	    <ul>
		<li>module-path Optional name/path of a module of the rack from which the value of
		    a certain input/output socket or state is to be retrieved.</li>
		<li>socket-type One of the following keywords: 
                    <ul>
                        <li>:input-socket The value of an input socket of the module.</li>
                        <li>:output-socket The value of an output socket of the module.</li>
                        <li>:state The value of an internal state that is exposed by the module.</li>
                    </ul>
                </li>
		<li>socket A keyword that identifies one of the input/output sockets or internal states provided by the module.</li>
                <li>any additional backend input-socket specific settings, like for example a column name.</li>
	    </ul>
	</li>
	<li>&rest additional-agent-args Optional keyword arguments to be passed to
	    the agent.</li>
    </ul></p></p>
<h3 id="wave-file-agent">wave-file-agent</h3><b>cl-synthesizer-monitor-wave-file-agent:make-backend</b>&nbsp;(name environment input-socket-settings &rest rest &key filename
 &allow-other-keys)<p>Creates a monitor backend which writes to a Wave file.
    <p>The function has the following parameters:
    <ul>
	<li>name A name.</li>
	<li>environment The synthesizer environment.</li>
	<li>input-socket-settings For each backend input-socket a list of settings.</li>
	<li>:filename A file path relative to the output directory as defined by the environment.</li>
    </ul></p>
    <p>The function returns a values object consisting of
    <ul>
       <li>A property list that implements a module (this is the Monitor-Backend).</li>
       <li>An ordered list of input sockets of the module.</li>
    </ul></p></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-monitor-wave-file-example-1
  (:use :cl))

(in-package :cl-synthesizer-monitor-wave-file-example-1)

(defun example ()
  &quot;Wave-File-Agent example&quot;
  (let ((rack (cl-synthesizer:make-rack :environment (cl-synthesizer:make-environment))))
    
    (cl-synthesizer:add-module
     rack &quot;VCO&quot; #'cl-synthesizer-modules-vco:make-module
     :base-frequency 5.0 :v-peak 5.0)

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-wave-file-agent:make-backend
     '((&quot;VCO&quot; :output-socket :sine))
     :filename &quot;cl-synthesizer-examples/monitor-wave-file-example-1.wav&quot;
     :v-peak 5.0)
    
    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 2)))

;; (run-example)</code></pre></p>
<h3 id="csv-file-agent">csv-file-agent</h3><b>cl-synthesizer-monitor-csv-file-agent:make-backend</b>&nbsp;(name environment input-socket-settings &rest rest &key filename
 &allow-other-keys)<p>Creates a monitor backend which writes to a CSV file.
    <p>The function has the following parameters:
    <ul>
	<li>name A name.</li>
	<li>environment The synthesizer environment.</li>
	<li>input-socket-settings For each backend input-socket a list of settings. For supported settings refer to cl-synthesizer-modules-csv-file-writer.</li>
	<li>:filename A file path relative to the output directory as defined by the environment.</li>
    </ul></p>
    <p>The function returns a values object consisting of
    <ul>
       <li>A property list that implements a module (this is the Monitor-Backend).</li>
       <li>An ordered list of input sockets of the module.</li>
    </ul></p></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-monitor-csv-file-example-1
  (:use :cl))

(in-package :cl-synthesizer-monitor-csv-file-example-1)

(defun example ()
  &quot;CSV-Agent example&quot;
  (let ((rack (cl-synthesizer:make-rack :environment (cl-synthesizer:make-environment))))
    
    (cl-synthesizer:add-module
     rack &quot;VCO&quot; #'cl-synthesizer-modules-vco:make-module :base-frequency 5.0 :v-peak 5.0)

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-csv-file-agent:make-backend
     '((&quot;VCO&quot; :output-socket :sine :name &quot;Sine&quot;))
     :filename &quot;cl-synthesizer-examples/monitor-csv-file-example-1.csv&quot;
     :add-header t
     :column-separator &quot;,&quot;)
    
    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 2)))

;; (run-example)</code></pre></p>
<h3 id="buffer-agent">buffer-agent</h3><b>cl-synthesizer-monitor-buffer-agent:make-backend</b>&nbsp;(name environment input-socket-settings &rest rest &key buffer
 &allow-other-keys)<p>Creates a monitor backend which writes to a memory buffer.
    <p>The function has the following parameters:
    <ul>
	<li>name A name.</li>
	<li>environment The synthesizer environment.</li>
	<li>input-socket-settings For each backend input-socket a list of settings.</li>
	<li>:buffer An array with dimension (length inputs).</li>
    </ul></p>
    <p>The function returns a values object consisting of
    <ul>
       <li>A property list that implements a module (this is the Monitor-Backend).</li>
       <li>An ordered list of input sockets of the module.</li>
    </ul></p></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-monitor-buffer-example-1
  (:use :cl))

(in-package :cl-synthesizer-monitor-buffer-example-1)

(defun example ()
  &quot;Buffer-Agent example&quot;
  (let ((rack (cl-synthesizer:make-rack :environment (cl-synthesizer:make-environment))))
    
    (cl-synthesizer:add-module
     rack &quot;VCO&quot; #'cl-synthesizer-modules-vco:make-module :base-frequency 5.0 :v-peak 5.0)

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-buffer-agent:make-backend
     '((&quot;VCO&quot; :output-socket :sine)
       (&quot;VCO&quot; :output-socket :saw))
     :buffer (make-array 2))
    
    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer:play-rack rack :duration-seconds 2)))

;; (run-example)</code></pre></p>
<h2 id="MIDI">MIDI</h2>
<h3 id="MIDI Event">MIDI Event</h3><b>cl-synthesizer-midi-event:make-control-change-event</b>&nbsp;(&key channel controller-number control-value)<p>Creates a MIDI control change event.</p><b>cl-synthesizer-midi-event:make-note-on-event</b>&nbsp;(&key channel note-number velocity)<p>Creates a MIDI Note-On event.</p><b>cl-synthesizer-midi-event:make-note-off-event</b>&nbsp;(&key channel note-number velocity)<p>Creates a MIDI Note-Off event.</p><b>cl-synthesizer-midi-event:control-change-eventp</b>&nbsp;(event)<p>Returns t if the given MIDI event is a Control-Change event.</p><b>cl-synthesizer-midi-event:note-on-eventp</b>&nbsp;(event)<p>Returns t if the given MIDI event is a Note-On event.</p><b>cl-synthesizer-midi-event:note-off-eventp</b>&nbsp;(event)<p>Returns t if the given MIDI event is a Note-Off event.</p><b>cl-synthesizer-midi-event:get-channel</b>&nbsp;(event)<p>Returns the MIDI channel number to which the event belongs.</p><b>cl-synthesizer-midi-event:get-controller-number</b>&nbsp;(event)<p>Returns the controller number of a Control-Change MIDI event.</p><b>cl-synthesizer-midi-event:get-control-value</b>&nbsp;(event)<p>Returns the control value of a Control-Change MIDI event.</p><b>cl-synthesizer-midi-event:get-note-number</b>&nbsp;(event)<p>Returns the note number of Note-On/Off MIDI event.</p><b>cl-synthesizer-midi-event:get-velocity</b>&nbsp;(event)<p>Returns the velocity of a Note-On/Off MIDI event.</p>
<h3 id="MIDI Polyphonic Interface">MIDI Polyphonic Interface</h3><b>cl-synthesizer-modules-midi-polyphonic-interface:make-module</b>&nbsp;(name environment &key (voice-count 1) (channel nil) (cv-gate-on 5.0)
 (cv-gate-off 0.0) (cv-velocity-max 5.0))<p>Creates a polyphonic MIDI interface module. The module dispatches MIDI-Note events to so called voices where each
    voice is represented by a pitch-control voltage, a velocity-control voltage and a gate signal.
    <p>The function has the following parameters:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:voice-count The number of voices to be exposed by the module.</li>
	<li>:channel Optional MIDI channel to which note events must belong. By default the
	    channel is ignored.</li>
	<li>:cv-gate-on The "Gate on" control voltage.</li>
	<li>:cv-gate-off The "Gate off" control voltage.</li>
	<li>:cv-velocity-max Control voltage that represents the maximum velocity of 127.</li>
    </ul>
    Gate transitions are implemented as follows: Each incoming "note on" event causes that the gate signal of the
    assigned voice switches to On. If the gate signal of the assigned voice is already On
    (this happens when the available voices are exhausted and a voice is "stolen") then
    the gate signal switches to Off for the duration of one system tick and then to On again.</p>
    <p>The module has the following inputs:
    <ul>
	<li>:midi-events A list of MIDI events.</li>
    </ul></p>
    <p>The module has the following outputs:
    <ul>
	<li>:gate-1 ... :gate-n Gate signal.</li>
	<li>:cv-1 ... :cv-n Pitch control voltage. cv = note-number / 12.0</li>
	<li>:velocity-1 ... :velocity-n Velocity control voltage.</li>
    </ul></p></p>
<h3 id="MIDI Monophonic Interface">MIDI Monophonic Interface</h3><b>cl-synthesizer-modules-midi-monophonic-interface:make-module</b>&nbsp;(name environment &key (channel nil) (cv-gate-on 5.0) (cv-gate-off 0.0)
 (force-gate-retrigger nil) (stack-depth 5) (cv-velocity-max 5.0)
 (force-velocity-update nil))<p>Creates a monophonic MIDI interface module. The module dispatches MIDI-Note events to a single voice. 
   If the voice is already assigned to a note, then the incoming note is pushed on top of the current note.
   <p>The function has the following parameters:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
        <li>:stack-depth Maximum number of stacked notes.</li>
	<li>:channel Optional MIDI channel to which note events must belong. By default the
	    channel is ignored.</li>
	<li>:cv-gate-on The "Gate on" control voltage.</li>
	<li>:cv-gate-off The "Gate off" control voltage.</li>
	<li>:force-gate-retrigger If t then each "note on" event will cause a retriggering 
            of the gate signal. Otherwise the gate signal will stay on when it is already on.</li>
	<li>:cv-velocity-max Control voltage that represents the maximum velocity (Velocity = 127).</li>
	<li>:force-velocity-update If t then each "note on" event will cause an
            update of the velocity control voltage according to the velocity of the current event.</li>
    </ul>
    Gate transitions are implemented as follows: Incoming notes are stacked. The 
    first ("initiating") "note on" event causes the gate signal to go up. The gate goes 
    down when after a "note off" event no more notes are on the stack.</p>
    <p>The module has the following inputs:
    <ul>
	<li>:midi-events A list of MIDI events.</li>
    </ul></p>
    <p>The module has the following outputs:
    <ul>
	<li>:gate The gate signal.</li>
	<li>:cv Pitch control voltage representing the note which is on top of the note stack. cv = note-number / 12.0</li>
	<li>:velocity Velocity control voltage. The velocity control voltage represents 
        the velocity of the initiating "note on" event (Gate goes up). Nested "note on" 
        events do not cause an update of this voltage. This behaviour can be overridden 
        by the :force-velocity-update parameter.</li>
    </ul></p></p>
<h3 id="MIDI Relative CC Interface">MIDI Relative CC Interface</h3><b>cl-synthesizer-modules-midi-relative-cc-interface:make-module</b>&nbsp;(name environment &key mappings (channel nil) (initial-output 0)
 (min-output nil) (max-output nil))<p>Creates a MIDI CC Event interface module. CC events are interpreted as relative 
   changes to the current output value.
   <p>The function has the following parameters:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:mappings A list of mappings. A mapping consists of a controller number, control values and a resulting offset 
          that will be added to the current output value of the module. A mapping can be defined as shown by the following examples:
          <ul>
             <li>(:controller-number 112 :control-value 61 :offset 1.0)</li>
             <li>(:controller-number 112 :control-value (:range 60 70) :offset 1.0)</li>
             <li>(:controller-number 112 :control-value (61 63 65) :offset 1.0)</li>
          </ul>
        </li>
        <li>:channel Optional number of the MIDI channel to which the controller events 
          must belong. By default there is no channel filtering applied.</li>
        <li>:initial-output The initial output value of the module.</li>
        <li>:min-output Optional lowest output value of the module.</li>
        <li>:max-output Optional largest output value of the module.</li>
    </ul></p>
    <p>The module has the following inputs:
    <ul>
	<li>:midi-events A list of MIDI events.</li>
    </ul></p>
    <p>The module has the following outputs:
    <ul>
	<li>:output The current output value.</li>
    </ul></p></p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-midi-relative-cc-interface-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-midi-relative-cc-interface-example-1)

(defun example ()
  &quot;MIDI Relative CC-Interface Example&quot;
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment))))

    (cl-synthesizer:add-module
     rack &quot;MIDI-CC-IFC&quot; #'cl-synthesizer-modules-midi-relative-cc-interface:make-module
     :mappings '((:controller-number 112 :control-value 61 :offset -1.0)
                 (:controller-number 112 :control-value 67 :offset 1.0))
     :initial-output 2.5
     :channel nil)

    (cl-synthesizer:add-module
     rack &quot;MIDI-SEQUENCER&quot;
     #'cl-synthesizer-modules-midi-sequencer:make-module :events
     (list 
      (list :timestamp-milli-seconds 100
            :midi-events (list
                          (cl-synthesizer-midi-event:make-control-change-event :channel 1 :controller-number 112 :control-value 61)))
      (list :timestamp-milli-seconds 200
            :midi-events (list
                          (cl-synthesizer-midi-event:make-control-change-event :channel 1 :controller-number 112 :control-value 61)))
      (list :timestamp-milli-seconds 300
            :midi-events (list
                          (cl-synthesizer-midi-event:make-control-change-event :channel 1 :controller-number 112 :control-value 61)))
      (list :timestamp-milli-seconds 400
            :midi-events (list
                          (cl-synthesizer-midi-event:make-control-change-event :channel 1 :controller-number 112 :control-value 61)))
      (list :timestamp-milli-seconds 500
            :midi-events (list
                          (cl-synthesizer-midi-event:make-control-change-event :channel 1 :controller-number 112 :control-value 67)))
      (list :timestamp-milli-seconds 600
            :midi-events (list
                          (cl-synthesizer-midi-event:make-control-change-event :channel 1 :controller-number 112 :control-value 67)))
      (list :timestamp-milli-seconds 700
            :midi-events (list
                          (cl-synthesizer-midi-event:make-control-change-event :channel 1 :controller-number 112 :control-value 67)))
      (list :timestamp-milli-seconds 800
            :midi-events (list
                          (cl-synthesizer-midi-event:make-control-change-event :channel 1 :controller-number 112 :control-value 67)))))
    
    (cl-synthesizer:add-patch rack &quot;MIDI-SEQUENCER&quot; :midi-events &quot;MIDI-CC-IFC&quot; :midi-events)

    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-csv-file-agent:make-backend
     '((&quot;MIDI-CC-IFC&quot; :output-socket :output :name &quot;CC-Out&quot;))
     :filename &quot;cl-synthesizer-examples/midi-relative-cc-interface-example-1.csv&quot;)

    rack))

(defun run-example ()
  (cl-synthesizer::play-rack (example) :duration-seconds 0.9))

;; (run-example)</code></pre></p>
<h3 id="MIDI Sequencer">MIDI Sequencer</h3><b>cl-synthesizer-modules-midi-sequencer:make-module</b>&nbsp;(name environment &key events)<p>Creates a Midi-Sequencer module.
    <p>The function has the following parameters:
    <ul>
	<li>name Name of the module.</li>
	<li>environment The synthesizer environment.</li>
	<li>:events A list of Midi events and their timestamps. Each
	    entry consists of a property list with the following keys:
	    <ul>
		<li>:timestamp-milli-seconds Point of time when events are to be fired. The very first
                timestamp of the synthesizer is 0.</li>
		<li>:midi-events List of Midi events to be fired.</li>
	    </ul>
            The events must be ordered by timestamp and there must be no duplicate timestamps. 
	</li>
    </ul></p>
    The module has no inputs.
    The module has one output socket :midi-events.</p><p><b>Example</b></p><p><pre><code>(defpackage :cl-synthesizer-modules-midi-sequencer-example-1
  (:use :cl))

(in-package :cl-synthesizer-modules-midi-sequencer-example-1)

(defun example ()
  &quot;Midi-Sequencer example&quot;
  (let ((rack (cl-synthesizer:make-rack
               :environment (cl-synthesizer:make-environment))))

    ;; Add sequencer
    (cl-synthesizer:add-module
     rack
     &quot;MIDI-SEQUENCER&quot;
     #'cl-synthesizer-modules-midi-sequencer:make-module :events
     (list 
      (list :timestamp-milli-seconds 0
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-on-event
                           :channel 1
                           :note-number 69
                           :velocity 100)))
      (list :timestamp-milli-seconds 1000
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-off-event
                           :channel 1
                           :note-number 69
                           :velocity 100)))
      (list :timestamp-milli-seconds 2000
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-on-event
                           :channel 1
                           :note-number 75
                           :velocity 100)))
      (list :timestamp-milli-seconds 2500
            :midi-events (list
                          (cl-synthesizer-midi-event:make-note-off-event
                           :channel 1
                           :note-number 75
                           :velocity 100)))))

    ;; Add MIDI Interface and connect it with the MIDI Sequencer
    (cl-synthesizer:add-module
     rack
     &quot;MIDI-IFC&quot;
     #'cl-synthesizer-modules-midi-polyphonic-interface:make-module :voice-count 1)
    (cl-synthesizer:add-patch rack &quot;MIDI-SEQUENCER&quot; :midi-events &quot;MIDI-IFC&quot; :midi-events)

    ;; Add VCO
    (cl-synthesizer:add-module
     rack &quot;VCO&quot; #'cl-synthesizer-modules-vco:make-module
     :base-frequency (cl-synthesizer-midi:get-note-number-frequency 0)
     :v-peak 5.0)

    ;; Add ADSR
    (cl-synthesizer:add-module
     rack &quot;ADSR&quot;
     #'cl-synthesizer-modules-adsr:make-module
     :attack-time-ms 100 :attack-target-output 5.0
     :decay-time-ms 50 :decay-target-output 3.0
     :release-time-ms 100)
    
    ;; Add VCA
    (cl-synthesizer:add-module rack &quot;VCA&quot; #'cl-synthesizer-modules-vca:make-module :cv-max 5.0 :exponential nil)

    ;; Connect VCA with ADSR and VCO
    (cl-synthesizer:add-patch rack &quot;ADSR&quot; :cv &quot;VCA&quot; :cv)
    (cl-synthesizer:add-patch rack &quot;VCO&quot; :triangle &quot;VCA&quot; :input)
    
    ;; Connect Midi interface with ADSR and VCO
    (cl-synthesizer:add-patch rack &quot;MIDI-IFC&quot; :cv-1 &quot;VCO&quot; :cv-exp)
    (cl-synthesizer:add-patch rack &quot;MIDI-IFC&quot; :gate-1 &quot;ADSR&quot; :gate)

    ;; Write VCA output to a wave file
    (cl-synthesizer-monitor:add-monitor
     rack
     #'cl-synthesizer-monitor-wave-file-agent:make-backend
     '((&quot;VCA&quot; :output-socket :output))
     :filename &quot;cl-synthesizer-examples/midi-sequencer-example-1.wav&quot;
     :v-peak 5.0)
    
    rack))

(defun run-example ()
  (let ((rack (example)))
    (cl-synthesizer::play-rack rack :duration-seconds 5)))

;; (run-example)</code></pre></p>
<h3 id="MIDI Utilities">MIDI Utilities</h3><b>cl-synthesizer-midi:get-note-number-frequency</b>&nbsp;(note-number)<p>Returns the frequency of a given note number. Note number 69 results in a frequency of 440Hz.
   This function implements a mapping according to 
   <a href="http://subsynth.sourceforge.net/midinote2freq.html">midinote2freq</a></p><table><thead><tr><th>Note number</th><th>Frequency</th></tr></thead><tbody>
<tr><td>0</td><td>8.175798</td></tr>
<tr><td>1</td><td>8.661958</td></tr>
<tr><td>2</td><td>9.177024</td></tr>
<tr><td>3</td><td>9.722718</td></tr>
<tr><td>4</td><td>10.300861</td></tr>
<tr><td>5</td><td>10.913383</td></tr>
<tr><td>6</td><td>11.5623255</td></tr>
<tr><td>7</td><td>12.249857</td></tr>
<tr><td>8</td><td>12.9782715</td></tr>
<tr><td>9</td><td>55/4</td></tr>
<tr><td>10</td><td>14.567618</td></tr>
<tr><td>11</td><td>15.433853</td></tr>
<tr><td>12</td><td>16.351597</td></tr>
<tr><td>13</td><td>17.323915</td></tr>
<tr><td>14</td><td>18.354048</td></tr>
<tr><td>15</td><td>19.445436</td></tr>
<tr><td>16</td><td>20.601723</td></tr>
<tr><td>17</td><td>21.826765</td></tr>
<tr><td>18</td><td>23.124651</td></tr>
<tr><td>19</td><td>24.499714</td></tr>
<tr><td>20</td><td>25.956543</td></tr>
<tr><td>21</td><td>55/2</td></tr>
<tr><td>22</td><td>29.135237</td></tr>
<tr><td>23</td><td>30.867706</td></tr>
<tr><td>24</td><td>32.703194</td></tr>
<tr><td>25</td><td>34.64783</td></tr>
<tr><td>26</td><td>36.708096</td></tr>
<tr><td>27</td><td>38.890873</td></tr>
<tr><td>28</td><td>41.203445</td></tr>
<tr><td>29</td><td>43.65353</td></tr>
<tr><td>30</td><td>46.249302</td></tr>
<tr><td>31</td><td>48.999428</td></tr>
<tr><td>32</td><td>51.913086</td></tr>
<tr><td>33</td><td>55</td></tr>
<tr><td>34</td><td>58.270473</td></tr>
<tr><td>35</td><td>61.735413</td></tr>
<tr><td>36</td><td>65.40639</td></tr>
<tr><td>37</td><td>69.29566</td></tr>
<tr><td>38</td><td>73.41619</td></tr>
<tr><td>39</td><td>77.781746</td></tr>
<tr><td>40</td><td>82.40689</td></tr>
<tr><td>41</td><td>87.30706</td></tr>
<tr><td>42</td><td>92.498604</td></tr>
<tr><td>43</td><td>97.998856</td></tr>
<tr><td>44</td><td>103.82617</td></tr>
<tr><td>45</td><td>110</td></tr>
<tr><td>46</td><td>116.54095</td></tr>
<tr><td>47</td><td>123.470825</td></tr>
<tr><td>48</td><td>130.81277</td></tr>
<tr><td>49</td><td>138.59132</td></tr>
<tr><td>50</td><td>146.83238</td></tr>
<tr><td>51</td><td>155.56349</td></tr>
<tr><td>52</td><td>164.81378</td></tr>
<tr><td>53</td><td>174.61412</td></tr>
<tr><td>54</td><td>184.99721</td></tr>
<tr><td>55</td><td>195.99771</td></tr>
<tr><td>56</td><td>207.65234</td></tr>
<tr><td>57</td><td>220</td></tr>
<tr><td>58</td><td>233.0819</td></tr>
<tr><td>59</td><td>246.94165</td></tr>
<tr><td>60</td><td>261.62555</td></tr>
<tr><td>61</td><td>277.18265</td></tr>
<tr><td>62</td><td>293.66476</td></tr>
<tr><td>63</td><td>311.12698</td></tr>
<tr><td>64</td><td>329.62756</td></tr>
<tr><td>65</td><td>349.22824</td></tr>
<tr><td>66</td><td>369.99442</td></tr>
<tr><td>67</td><td>391.99542</td></tr>
<tr><td>68</td><td>415.3047</td></tr>
<tr><td>69</td><td>440</td></tr>
<tr><td>70</td><td>466.1638</td></tr>
<tr><td>71</td><td>493.8833</td></tr>
<tr><td>72</td><td>523.2511</td></tr>
<tr><td>73</td><td>554.3653</td></tr>
<tr><td>74</td><td>587.3295</td></tr>
<tr><td>75</td><td>622.25397</td></tr>
<tr><td>76</td><td>659.2551</td></tr>
<tr><td>77</td><td>698.4565</td></tr>
<tr><td>78</td><td>739.98883</td></tr>
<tr><td>79</td><td>783.99084</td></tr>
<tr><td>80</td><td>830.6094</td></tr>
<tr><td>81</td><td>880</td></tr>
<tr><td>82</td><td>932.3276</td></tr>
<tr><td>83</td><td>987.7666</td></tr>
<tr><td>84</td><td>1046.5022</td></tr>
<tr><td>85</td><td>1108.7306</td></tr>
<tr><td>86</td><td>1174.659</td></tr>
<tr><td>87</td><td>1244.5079</td></tr>
<tr><td>88</td><td>1318.5103</td></tr>
<tr><td>89</td><td>1396.913</td></tr>
<tr><td>90</td><td>1479.9777</td></tr>
<tr><td>91</td><td>1567.9817</td></tr>
<tr><td>92</td><td>1661.2188</td></tr>
<tr><td>93</td><td>1760</td></tr>
<tr><td>94</td><td>1864.6552</td></tr>
<tr><td>95</td><td>1975.5332</td></tr>
<tr><td>96</td><td>2093.0044</td></tr>
<tr><td>97</td><td>2217.4612</td></tr>
<tr><td>98</td><td>2349.318</td></tr>
<tr><td>99</td><td>2489.0159</td></tr>
<tr><td>100</td><td>2637.0205</td></tr>
<tr><td>101</td><td>2793.826</td></tr>
<tr><td>102</td><td>2959.9553</td></tr>
<tr><td>103</td><td>3135.9634</td></tr>
<tr><td>104</td><td>3322.4375</td></tr>
<tr><td>105</td><td>3520</td></tr>
<tr><td>106</td><td>3729.3103</td></tr>
<tr><td>107</td><td>3951.0664</td></tr>
<tr><td>108</td><td>4186.009</td></tr>
<tr><td>109</td><td>4434.9224</td></tr>
<tr><td>110</td><td>4698.636</td></tr>
<tr><td>111</td><td>4978.0317</td></tr>
<tr><td>112</td><td>5274.041</td></tr>
<tr><td>113</td><td>5587.652</td></tr>
<tr><td>114</td><td>5919.9106</td></tr>
<tr><td>115</td><td>6271.927</td></tr>
<tr><td>116</td><td>6644.875</td></tr>
<tr><td>117</td><td>7040</td></tr>
<tr><td>118</td><td>7458.6206</td></tr>
<tr><td>119</td><td>7902.133</td></tr>
<tr><td>120</td><td>8372.018</td></tr>
<tr><td>121</td><td>8869.845</td></tr>
<tr><td>122</td><td>9397.272</td></tr>
<tr><td>123</td><td>9956.063</td></tr>
<tr><td>124</td><td>10548.082</td></tr>
<tr><td>125</td><td>11175.304</td></tr>
<tr><td>126</td><td>11839.821</td></tr>
<tr><td>127</td><td>12543.854</td></tr>
</tbody></table>

<h2 id="Conditions">Conditions</h2><b>cl-synthesizer:assembly-error</b><p>This condition is signalled in cases where the assembly of a rack fails,
   because for example a module name is not unique, a module is malformed, a patch is added for
   a non-existing module, a patch is added to an already patched socket and so on.</p>
<h1 id="Run tests">Run tests</h1><pre><code>(asdf:test-system :cl-synthesizer)</code></pre>
<h1 id="Run examples">Run examples</h1>Run all examples of cl-synthesizer. Generated files are written to <code>~/cl-synthesizer-examples/</code><p><pre><code>(asdf:load-system :cl-synthesizer/examples)
(cl-synthesizer-examples::run-examples)</code></pre></p>
<h1 id="Run profiler">Run profiler</h1>Run the profiling suite. Generated files files are written to <code>~/cl-synthesizer-profiler/</code><p><pre><code>(asdf:load-system :cl-synthesizer/profiling)
(cl-synthesizer-profiling::run-all)</code></pre></p>
<h1 id="Generate documentation">Generate documentation</h1>Depends on :cl-html-readme and :docparser which are available via Quicklisp.<p><pre><code>(asdf:load-system :cl-synthesizer/doc)
(cl-synthesizer-make-doc::make-doc)</code></pre></p>
<h1 id="Acknowledgements">Acknowledgements</h1><p>Envelope generation has been inspired by <a href="https://github.com/dhemery/DHE-Modules/wiki/Multi-Stage-Envelopes">dhemery</a></p></section>
<footer><hr/><p><small>Generated 2025-04-04  21:57:37 (cl-html-readme 3.0.0)</small></p></footer></body></html>