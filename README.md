# cl-synthesizer
An experimental modular audio synthesizer implemented in Common Lisp

Work In Progress...

## Architecture

A Synthesizer is represented by an instance of Rack. A Rack holds instances of Rack-Modules. A Rack-Module
holds one instance of a Module (a low level input/output component) and the connections to other Rack-Modules. 
For the integration of specific Midi-Hardware or Audio-Drivers a Rack provides MIDI-INPUT and LINE-OUT sockets.
These sockets can be connected with so called Devices. A Device may be a CoreMidi binding or a Midi-File-Reader 
that signals Midi-Events into the Rack, or an Audio-Driver that is fed with the signal generated by the Rack.

## Module

A Module is the basic component of a synthesizer. All signals of a synthesizer are generated by Modules. A Module
does not know anything about other modules or the Rack.

Modules are defined as constructor functions to which a name, an environment and arbitrary additional parameters as required 
by the module are passed. The environment provides settings such as the sample rate of the Rack and Event-Logging hooks.
The constructor function must return an alist with the following properties:

- :shutdown -- a function that is called when the Rack is shutting down.
- :inputs -- a function that returns a list of keywords representing the inputs of the module. 
- :outputs -- a function that returns a list of keywords representing the outputs of the module. 
- :get-output(output) -- a function that returns the current value of the given output.
- :update(inputs) -- a function that updates the state of the module. It is called with all input values (as declared by the inputs function) as keyword parameters. Undefined (not connected) inputs are not passed.

## Rack-Module

A Rack-Module is a Rack-internal component that encapsulates a Module, its input/output connections to other Rack-Modules, 
an Update-State etc. It is a Rack specific thing and if you are implementing a Module or assembling a Rack
you can ignore it.   

## Rack

TODO

